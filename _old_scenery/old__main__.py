import json

# from pprint import pformat

# from app.tests.utils import tabulate
from app.tests.views import SysConfig  # , logger_scenery, logger_rehearsal
from app.tests.views.coverage import RehearsalCoverageRunner, MetatestCoverageRunner
from app.tests.views.metatest import MetaTestRunner
from app.tests.views.unittest import RehearsalRunner

# from app.tests.views.logging import logger_scenery


# See also for later
#     Intelligent verification
#     Linear code sequence and jump
#     Mutation testing
#     Regression testing
#     Software metric
#     Static program analysis
#     White-box testing
#     Doctest
#     Type checking
#     Factoring / design


def main():

    result = {}

    ####################
    # LOGGERS
    ####################

    import logging

    # TODO: ajuster avec les micro secondes
    # TODO: move in __init__ or logging

    level = logging.DEBUG

    # Format
    format_log = "[%(asctime)s.%(msecs)03d] [%(name)s] [%(levelname)s] %(message)s"
    datefmt_ = "%Y-%m-%d %H:%M:%S"
    formatter = logging.Formatter(fmt=format_log, datefmt=datefmt_)

    # Handlers

    handler_full = logging.FileHandler(f"{SysConfig.this_folder}/scenery.log", mode="w")
    handler_full.setFormatter(formatter)
    handler_full.setLevel(level)

    # Scenery
    logger = logging.getLogger(__package__)
    logger.addHandler(handler_full)
    logger.setLevel(level)

    # Rehearsal
    logger_rehearsal = logging.getLogger(__package__ + ".rehearsal")
    logger_rehearsal.addHandler(handler_full)
    logger_rehearsal.setLevel(level)
    logger_rehearsal.propagate = False

    # Rehearsal django
    logger_rehearsal_django = logging.getLogger(__package__ + ".rehearsal.django")
    logger_rehearsal_django.addHandler(handler_full)
    logger_rehearsal_django.setLevel(level)
    # This is a bit brutal/rough/ugly
    logger_rehearsal_django.manager.disable = logging.NOTSET
    logger_rehearsal_django.propagate = False

    logger_app = logging.getLogger("app.close_watch")
    logger_app.handlers = []
    logger_app.addHandler(handler_full)
    logger_app.setLevel(level)

    #################
    # PARSE ARGUMENTS
    #################

    import argparse

    parser = argparse.ArgumentParser()

    choices_coverage = ["testcase", "test", "function", "statement", "branch"]

    def coverage_args_as_kwargs(l):
        """
        This is actually applied not as type argument of parser.add_argument
        as this would uselessly increase the number of choices, which would be required
        to be generated by itertools
        """
        nonlocal choices_coverage
        if "all" in l:
            d = {key: True for key in choices_coverage}
        else:
            d = {key: key in l for key in choices_coverage}
        return d

    parser.add_argument(
        "-v",
        "--verbose",
        dest="verbosity",
        type=int,
        default=2,
        help="Verbose output",
    )

    parser.add_argument(
        "-r",
        "--rehearsal",
        dest="run_rehearsal",
        action="store_true",
        help="Run rehearsal",
    )

    parser.add_argument(
        "-rcov",
        "--rehearsalcoverage",
        nargs="+",
        choices=choices_coverage + ["all"],
        default=list(),
        dest="rehearsal_coverage",
        action="store",
        help="Run rehearsal coverage",
    )

    parser.add_argument(
        "-m",
        "--metatesting",
        dest="run_metatesting",
        action="store_true",
        help="Run metatesting",
    )

    parser.add_argument(
        "-mcov",
        "--metatestingcoverage",
        nargs="+",
        choices=choices_coverage + ["all"],
        default=list(),
        dest="metatesting_coverage",
        action="store",
        help="Run metatesting coverage",
    )

    parser.add_argument(
        "--view",
        dest="restrict_view_name",
        action="store",
        default=None,
        help="Restrict to a specific view",
    )

    # parser.add_argument(
    #     "--output",
    #     default=None,
    #     dest="output",
    #     action="store",
    #     help="Export output",
    # )

    args = parser.parse_args()

    result["args"] = args.__dict__

    if args.rehearsal_coverage or args.metatesting_coverage:
        import warnings

        warnings.warn("Coverage is experimental and untested.", UserWarning)

    #############
    # CONFIG
    #############

    result["config"] = {
        "stdlib": SysConfig.stdlib,
        "purelib": SysConfig.purelib,
        "src": SysConfig.src,
        "this_folder": SysConfig.this_folder,
    }

    for key, val in result["config"].items():
        logger.debug(f"`{key}` found at {val}")

    #############
    # REHEARSAL
    #############

    # Tests
    if args.run_rehearsal:
        rehearsal = RehearsalRunner()
        result["rehearsal"] = rehearsal.run(args.verbosity)
    else:
        logger.info("Skipped rehearsal.")

    # Coverage
    if args.rehearsal_coverage:
        rehearsal_coverage = RehearsalCoverageRunner()
        args.rehearsal_coverage = coverage_args_as_kwargs(args.rehearsal_coverage)
        result["rehearsal coverage"] = rehearsal_coverage.run(**args.rehearsal_coverage)

        # Log
        for key, val in args.rehearsal_coverage.items():
            if not val:
                logger.debug(f"Skipped {key} coverage")
    else:
        logger.info("Skipped rehearsal coverage.")

    #############
    # METATESTING
    #############

    # Tests
    if args.run_metatesting:

        metatesting = MetaTestRunner()
        result["metatesting"] = metatesting.run(args.verbosity, args.restrict_view_name)
    else:
        logger.info("Skipped metatesting.")

    # Tests coverage
    if args.metatesting_coverage:
        if "test" in args.metatesting_coverage:
            msg = "Test coverage is not implemented for metatesting"
            logger.error(msg)
            raise NotImplementedError(msg)
        metatesting_coverage = MetatestCoverageRunner()
        args.metatesting_coverage = coverage_args_as_kwargs(args.metatesting_coverage)
        del args.metatesting_coverage["test"]
        result["metatesting coverage"] = metatesting_coverage.run(
            **args.metatesting_coverage
        )
    else:
        logger.info("Skipped metatesting coverage.")

    ###############
    # OUTPUT RESULT
    ###############

    # TODO : reconsider the correct Way for fucking Git

    # with open("app/tests/views/scenery.json", "w") as f:
    #     json.dump(result, f)


if __name__ == "__main__":

    import sys

    main()

    sys.exit(0)
