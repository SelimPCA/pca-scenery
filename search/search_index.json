{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#common","title":"Common","text":"<p>General functions and classes used by other modules</p>"},{"location":"api/#scenery.common.colorize","title":"<code>colorize</code>","text":"<p>A context manager for colorizing text in the console.</p> <p>This class can be used either as a context manager or called directly to wrap text in color codes.</p> <p>Attributes:</p> Name Type Description <code>colors</code> <code>dict</code> <p>A dictionary mapping color names to ANSI color codes.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize the colorize object.</p> <code>__enter__</code> <p>Set the color when entering the context.</p> <code>__exit__</code> <p>Reset the color when exiting the context.</p> <code>__str__</code> <p>Return the colorized text if text was provided.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str or callable</code> <p>The color to use, either as a string or a function that returns a color.</p> required <code>text</code> <code>str</code> <p>The text to colorize. If provided, the object can be used directly as a string.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If a color mapping function is provided without text.</p> Source code in <code>scenery/common.py</code> <pre><code>class colorize:\n    \"\"\"\n    A context manager for colorizing text in the console.\n\n    This class can be used either as a context manager or called directly to wrap text in color codes.\n\n    Attributes:\n        colors (dict): A dictionary mapping color names to ANSI color codes.\n\n    Methods:\n        __init__(self, color, text=None): Initialize the colorize object.\n        __enter__(self): Set the color when entering the context.\n        __exit__(self, exc_type, exc_val, exc_tb): Reset the color when exiting the context.\n        __str__(self): Return the colorized text if text was provided.\n\n    Args:\n        color (str or callable): The color to use, either as a string or a function that returns a color.\n        text (str, optional): The text to colorize. If provided, the object can be used directly as a string.\n\n    Raises:\n        Exception: If a color mapping function is provided without text.\n    \"\"\"\n\n    colors = {\n        \"red\": \"\\033[31m\",\n        \"green\": \"\\033[32m\",\n        \"yellow\": \"\\033[33m\",\n        \"blue\": \"\\033[34m\",\n        \"magenta\": \"\\033[35m\",\n        \"cyan\": \"\\033[36m\",\n        \"white\": \"\\033[37m\",\n        \"reset\": \"\\033[0m\",\n    }\n\n    def __init__(self, color: str | typing.Callable, text: typing.Optional[str] = None) -&gt; None:\n        if callable(color):\n            if text is None:\n                raise ValueError(\"Cannot provide a color mapping without text\")\n            self.color = color(text)\n\n        else:\n            self.color = color\n        self.text = text\n\n    def __enter__(self) -&gt; \"colorize\":\n        print(self.colors[self.color], end=\"\")  # Set the color\n        return self  # Return context manager itself if needed\n\n    def __exit__(\n        self,\n        exc_type: typing.Optional[typing.Type[BaseException]],\n        exc_val: typing.Optional[BaseException],\n        exc_tb: typing.Optional[types.TracebackType],\n    ) -&gt; None:\n        print(self.colors[\"reset\"], end=\"\")  # Reset the color\n\n    def __str__(self) -&gt; str:\n        if self.text is not None:\n            return f\"{self.colors[self.color]}{self.text}{self.colors['reset']}\"\n        else:\n            return \"\"\n</code></pre>"},{"location":"api/#scenery.common.ceil","title":"<code>ceil(n)</code>","text":"<p>Return the ceiling of a number.</p> <p>If the input is an integer, it returns the input unchanged. For floating-point numbers, it returns the smallest integer greater than or equal to the input.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int or float</code> <p>The number to ceil.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ceiling of the input number.</p> Source code in <code>scenery/common.py</code> <pre><code>def ceil(n: numbers.Real) -&gt; int:\n    \"\"\"\n    Return the ceiling of a number.\n\n    If the input is an integer, it returns the input unchanged.\n    For floating-point numbers, it returns the smallest integer greater than or equal to the input.\n\n    Args:\n        n (int or float): The number to ceil.\n\n    Returns:\n        int: The ceiling of the input number.\n    \"\"\"\n    # NOTE: this was just to avoid another dependency\n    if isinstance(n, int):\n        return n\n    else:\n        return int(n // 1) + 1\n</code></pre>"},{"location":"api/#scenery.common.django_setup","title":"<code>django_setup(settings_module)</code>","text":"<p>Set up the Django environment.</p> <p>This function sets the DJANGO_SETTINGS_MODULE environment variable and calls django.setup().</p> <p>Parameters:</p> Name Type Description Default <code>settings_module</code> <code>str</code> <p>The import path to the Django settings module.</p> required Source code in <code>scenery/common.py</code> <pre><code>def django_setup(settings_module: str) -&gt; None:\n    \"\"\"\n    Set up the Django environment.\n\n    This function sets the DJANGO_SETTINGS_MODULE environment variable and calls django.setup().\n\n    Args:\n        settings_module (str): The import path to the Django settings module.\n    \"\"\"\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", settings_module)\n    django.setup()\n</code></pre>"},{"location":"api/#scenery.common.floor","title":"<code>floor(n)</code>","text":"<p>Return the floor of a number.</p> <p>If the input is an integer, it returns the input unchanged. For floating-point numbers, it returns the largest integer less than or equal to the input.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int or float</code> <p>The number to floor.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The floor of the input number.</p> Source code in <code>scenery/common.py</code> <pre><code>def floor(n: numbers.Real) -&gt; int:\n    \"\"\"\n    Return the floor of a number.\n\n    If the input is an integer, it returns the input unchanged.\n    For floating-point numbers, it returns the largest integer less than or equal to the input.\n\n    Args:\n        n (int or float): The number to floor.\n\n    Returns:\n        int: The floor of the input number.\n    \"\"\"\n    # NOTE: this was just to avoid another dependency\n    if isinstance(n, int):\n        return n\n    else:\n        return int(n // 1)\n</code></pre>"},{"location":"api/#scenery.common.overwrite_get_runner_kwargs","title":"<code>overwrite_get_runner_kwargs(django_runner, stream)</code>","text":"<p>Overwrite the get_runner_kwargs method of Django's DiscoverRunner.</p> <p>This function is used to avoid printing Django test output by redirecting the stream.</p> <p>Parameters:</p> Name Type Description Default <code>django_runner</code> <code>DiscoverRunner</code> <p>The Django test runner instance.</p> required <code>stream</code> <code>IO</code> <p>The stream to redirect output to.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of keyword arguments for the test runner.</p> Notes <p>see django.test.runner.DiscoverRunner.get_runner_kwargs</p> Source code in <code>scenery/common.py</code> <pre><code>def overwrite_get_runner_kwargs(django_runner: DiscoverRunner, stream: typing.IO) -&gt; dict:\n    \"\"\"\n    Overwrite the get_runner_kwargs method of Django's DiscoverRunner.\n\n    This function is used to avoid printing Django test output by redirecting the stream.\n\n    Args:\n        django_runner (DiscoverRunner): The Django test runner instance.\n        stream: The stream to redirect output to.\n\n    Returns:\n        dict: A dictionary of keyword arguments for the test runner.\n\n    Notes:\n        see django.test.runner.DiscoverRunner.get_runner_kwargs\n    \"\"\"\n    kwargs = {\n        \"failfast\": django_runner.failfast,\n        \"resultclass\": django_runner.get_resultclass(),\n        \"verbosity\": django_runner.verbosity,\n        \"buffer\": django_runner.buffer,\n    }\n    kwargs.update({\"stream\": stream})\n    return kwargs\n</code></pre>"},{"location":"api/#scenery.common.pretty_test_name","title":"<code>pretty_test_name(test)</code>","text":"<p>Generate a pretty string representation of a unittest.TestCase.</p> <p>Parameters:</p> Name Type Description Default <code>test</code> <code>TestCase</code> <p>The test case to generate a name for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string in the format \"module.class.method\" representing the test case.</p> Source code in <code>scenery/common.py</code> <pre><code>def pretty_test_name(test: unittest.TestCase) -&gt; str:\n    \"\"\"\n    Generate a pretty string representation of a unittest.TestCase.\n\n    Args:\n        test (unittest.TestCase): The test case to generate a name for.\n\n    Returns:\n        str: A string in the format \"module.class.method\" representing the test case.\n    \"\"\"\n    return f\"{test.__module__}.{test.__class__.__qualname__}.{test._testMethodName}\"\n</code></pre>"},{"location":"api/#scenery.common.read_yaml","title":"<code>read_yaml(filename)</code>","text":"<p>Read and parse a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file to be read.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The parsed content of the YAML file.</p> <p>Raises:</p> Type Description <code>YAMLError</code> <p>If there's an error parsing the YAML file.</p> <code>IOError</code> <p>If there's an error reading the file.</p> Source code in <code>scenery/common.py</code> <pre><code>def read_yaml(filename: str) -&gt; typing.Any:\n    \"\"\"\n    Read and parse a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file to be read.\n\n    Returns:\n        Any: The parsed content of the YAML file.\n\n    Raises:\n        yaml.YAMLError: If there's an error parsing the YAML file.\n        IOError: If there's an error reading the file.\n    \"\"\"\n    with open(filename, \"r\") as f:\n        return yaml.safe_load(f)\n</code></pre>"},{"location":"api/#scenery.common.scenery_setup","title":"<code>scenery_setup(settings_location)</code>","text":"<p>Read the settings module and set the corresponding environment variables. This function imports the specified settings module and sets environment variables based on its contents. The following environment variables are set:</p> <p>SCENERY_COMMON_ITEMS SCENERY_SET_UP_INSTRUCTIONS SCENERY_TESTED_APP_NAME SCENERY_MANIFESTS_FOLDER</p> <p>Parameters:</p> Name Type Description Default <code>settings_location</code> <code>str</code> <p>The location (import path) of the settings module.</p> required <p>Raises:     ImportError: If the settings module cannot be imported.</p> Source code in <code>scenery/common.py</code> <pre><code>def scenery_setup(settings_location: str) -&gt; None:\n    \"\"\"\n    Read the settings module and set the corresponding environment variables.\n    This function imports the specified settings module and sets environment variables\n    based on its contents. The following environment variables are set:\n\n    SCENERY_COMMON_ITEMS\n    SCENERY_SET_UP_INSTRUCTIONS\n    SCENERY_TESTED_APP_NAME\n    SCENERY_MANIFESTS_FOLDER\n\n    Args:\n        settings_location (str): The location (import path) of the settings module.\n    Raises:\n        ImportError: If the settings module cannot be imported.\n    \"\"\"\n\n    # Load from module\n    settings = importlib.import_module(settings_location)\n\n    # Env variables\n    os.environ[\"SCENERY_COMMON_ITEMS\"] = settings.SCENERY_COMMON_ITEMS\n    os.environ[\"SCENERY_SET_UP_INSTRUCTIONS\"] = settings.SCENERY_SET_UP_INSTRUCTIONS\n    os.environ[\"SCENERY_TESTED_APP_NAME\"] = settings.SCENERY_TESTED_APP_NAME\n    os.environ[\"SCENERY_MANIFESTS_FOLDER\"] = settings.SCENERY_MANIFESTS_FOLDER\n</code></pre>"},{"location":"api/#scenery.common.serialize_unittest_result","title":"<code>serialize_unittest_result(result)</code>","text":"<p>Serialize a unittest.TestResult object into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>TestResult</code> <p>The TestResult object to serialize.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the serialized TestResult data.</p> Source code in <code>scenery/common.py</code> <pre><code>def serialize_unittest_result(result: unittest.TestResult) -&gt; dict:\n    \"\"\"\n    Serialize a unittest.TestResult object into a dictionary.\n\n    Args:\n        result (unittest.TestResult): The TestResult object to serialize.\n\n    Returns:\n        dict: A dictionary containing the serialized TestResult data.\n    \"\"\"\n    d: dict = {\n        attr: getattr(result, attr)\n        for attr in [\n            \"failures\",\n            \"errors\",\n            \"testsRun\",\n            \"skipped\",\n            \"expectedFailures\",\n            \"unexpectedSuccesses\",\n        ]\n    }\n    d = {key: len(val) if isinstance(val, list) else val for key, val in d.items()}\n    return d\n</code></pre>"},{"location":"api/#scenery.common.snake_to_camel_case","title":"<code>snake_to_camel_case(s)</code>","text":"<p>Transform a string from snake_case to CamelCase.</p> <p>This function assumes the input string is in snake_case format and converts it to CamelCase. It also handles strings containing '/' and '-' characters.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The input string in snake_case format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The input string converted to CamelCase.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input string is not in valid snake_case format.</p> Source code in <code>scenery/common.py</code> <pre><code>def snake_to_camel_case(s: str) -&gt; str:\n    \"\"\"\n    Transform a string from snake_case to CamelCase.\n\n    This function assumes the input string is in snake_case format and converts it to CamelCase.\n    It also handles strings containing '/' and '-' characters.\n\n    Args:\n        s (str): The input string in snake_case format.\n\n    Returns:\n        str: The input string converted to CamelCase.\n\n    Raises:\n        ValueError: If the input string is not in valid snake_case format.\n    \"\"\"\n    s = s.replace(\"/\", \"_\")\n    s = s.replace(\"-\", \"\")\n    if not re.fullmatch(r\"[a-z0-9_]+\", s):\n        raise ValueError(f\"'{s}' is not snake_case\")\n    words = s.split(\"_\")\n    camel_case = \"\".join(word.capitalize() for word in words)\n    return camel_case\n</code></pre>"},{"location":"api/#scenery.common.tabulate","title":"<code>tabulate(d, color=None, delim=':')</code>","text":"<p>Return an ASCII table for a dictionary with columns [key, value].</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dictionary to tabulate.</p> required <code>color</code> <code>str or callable</code> <p>The color to use for the values.</p> <code>None</code> <code>delim</code> <code>str</code> <p>The delimiter to use between keys and values. Defaults to ':'.</p> <code>':'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the tabulated dictionary.</p> Source code in <code>scenery/common.py</code> <pre><code>def tabulate(d: dict, color: typing.Callable | str | None = None, delim: str = \":\") -&gt; str:\n    \"\"\"\n    Return an ASCII table for a dictionary with columns [key, value].\n\n    Args:\n        d (dict): The dictionary to tabulate.\n        color (str or callable, optional): The color to use for the values.\n        delim (str, optional): The delimiter to use between keys and values. Defaults to ':'.\n\n    Returns:\n        str: A string representation of the tabulated dictionary.\n    \"\"\"\n    width = max(len(key) for key in d.keys())\n    table: list = [(key, val) for key, val in d.items()]\n    if color:\n        table = [(key, colorize(color, val)) for key, val in table]\n    table = [(\"\\t\", key.ljust(width), delim, str(val)) for key, val in table]\n    table = [\"\".join(line) for line in table]\n    return \"\\n\".join(table)\n</code></pre>"},{"location":"api/#http-checker","title":"Http Checker","text":"<p>Perform assertions on HTTP response</p>"},{"location":"api/#scenery.http_checker.HttpChecker","title":"<code>HttpChecker</code>","text":"<p>A utility class for performing HTTP requests and assertions on responses.</p> <p>This class provides static methods to execute HTTP requests and perform various checks on the responses, as specified in the test manifests.</p> Source code in <code>scenery/http_checker.py</code> <pre><code>class HttpChecker:\n    \"\"\"\n    A utility class for performing HTTP requests and assertions on responses.\n\n    This class provides static methods to execute HTTP requests and perform\n    various checks on the responses, as specified in the test manifests.\n    \"\"\"\n\n    @staticmethod\n    def get_http_client_response(client, take: scenery.manifest.HttpTake):\n        \"\"\"\n        Execute an HTTP request based on the given HttpTake object.\n\n        Args:\n            client: The Django test client to use for the request.\n            take (scenery.manifest.HttpTake): The HttpTake object specifying the request details.\n\n        Returns:\n            django.http.HttpResponse: The response from the HTTP request.\n\n        Raises:\n            NotImplementedError: If the HTTP method specified in the take is not implemented.\n        \"\"\"\n\n        match take.method:\n            case http.HTTPMethod.GET:\n                response = client.get(\n                    take.url,\n                    take.data,\n                )\n            case http.HTTPMethod.POST:\n                response = client.post(\n                    take.url,\n                    take.data,\n                )\n            case _:\n                raise NotImplementedError(take.method)\n\n        return response\n\n    @staticmethod\n    def exec_check(\n        django_testcase: django.test.TestCase,\n        response: django.http.HttpResponse,\n        check: scenery.manifest.HttpCheck,\n    ):\n        \"\"\"\n        Execute a specific check on an HTTP response.\n\n        This method delegates to the appropriate check method based on the instruction\n        specified in the HttpCheck object.\n\n        Args:\n            django_testcase (django.test.TestCase): The Django test case instance.\n            response (django.http.HttpResponse): The HTTP response to check.\n            check (scenery.manifest.HttpCheck): The check to perform on the response.\n\n        Raises:\n            NotImplementedError: If the check instruction is not implemented.\n        \"\"\"\n        match check.instruction:\n            case scenery.manifest.DirectiveCommand.STATUS_CODE:\n                HttpChecker.check_status_code(django_testcase, response, check.args)\n            case scenery.manifest.DirectiveCommand.REDIRECT_URL:\n                HttpChecker.check_redirect_url(django_testcase, response, check.args)\n            case scenery.manifest.DirectiveCommand.COUNT_INSTANCES:\n                HttpChecker.check_count_instances(django_testcase, response, check.args)\n            case scenery.manifest.DirectiveCommand.DOM_ELEMENT:\n                HttpChecker.check_dom_element(django_testcase, response, check.args)\n            case _:\n                raise NotImplementedError(check)\n\n    @staticmethod\n    def check_status_code(\n        django_testcase: django.test.TestCase,\n        response: django.http.HttpResponse,\n        args: int,\n    ):\n        \"\"\"\n        Check if the response status code matches the expected code.\n\n        Args:\n            django_testcase (django.test.TestCase): The Django test case instance.\n            response (django.http.HttpResponse): The HTTP response to check.\n            args (int): The expected status code.\n        \"\"\"\n        django_testcase.assertEqual(\n            response.status_code,\n            args,\n            f\"Expected status code {args}, but got {response.status_code}\",\n        )\n\n    @staticmethod\n    def check_redirect_url(\n        django_testcase: django.test.TestCase,\n        response: django.http.HttpResponseRedirect,\n        args: str,\n    ):\n        \"\"\"\n        Check if the response redirect URL matches the expected URL.\n\n        Args:\n            django_testcase (django.test.TestCase): The Django test case instance.\n            response (django.http.HttpResponseRedirect): The HTTP redirect response to check.\n            args (str): The expected redirect URL.\n        \"\"\"\n        django_testcase.assertEqual(\n            response.url,\n            args,\n            f\"Expected redirect URL '{args}', but got '{response.url}'\",\n        )\n\n    @staticmethod\n    def check_count_instances(\n        django_testcase: django.test.TestCase,\n        response: django.http.HttpResponse,\n        args: dict,\n    ):\n        \"\"\"\n        Check if the count of model instances matches the expected count.\n\n        Args:\n            django_testcase (django.test.TestCase): The Django test case instance.\n            response (django.http.HttpResponse): The HTTP response (not used in this check).\n            args (dict): A dictionary containing 'model' (the model class) and 'n' (expected count).\n        \"\"\"\n        instances = list(args[\"model\"].objects.all())\n        django_testcase.assertEqual(\n            len(instances),\n            args[\"n\"],\n            f\"Expected {args['n']} instances of {args['model'].__name__}, but found {len(instances)}\",\n        )\n\n    @staticmethod\n    def check_dom_element(\n        django_testcase: django.test.TestCase,\n        response: django.http.HttpResponse,\n        args: dict[scenery.manifest.DomArgument, Any],\n    ):\n        \"\"\"\n        Check for the presence and properties of DOM elements in the response content.\n\n        This method uses BeautifulSoup to parse the response content and perform various\n        checks on DOM elements as specified in the args dictionary.\n\n        Args:\n            django_testcase (django.test.TestCase): The Django test case instance.\n            response (django.http.HttpResponse): The HTTP response to check.\n            args (dict): A dictionary of DomArgument keys and their corresponding values,\n                         specifying the checks to perform.\n\n        Raises:\n            ValueError: If neither 'find' nor 'find_all' arguments are provided in args.\n        \"\"\"\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n\n        # Apply the scope\n        if scope := args.get(scenery.manifest.DomArgument.SCOPE):\n            soup = soup.find(**scope)\n\n        # Locate the element(s)\n        # If find_all is provided, the checks are performed on ALL elements\n        # If find is provided we enforce the result to be la list\n        if args.get(scenery.manifest.DomArgument.FIND_ALL):\n            dom_elements = soup.find_all(**args[scenery.manifest.DomArgument.FIND_ALL])\n            django_testcase.assertGreaterEqual(\n                len(dom_elements),\n                1,\n                f\"Expected to find at least one element matching {args[scenery.manifest.DomArgument.FIND_ALL]}, but found none\",\n            )\n        elif args.get(scenery.manifest.DomArgument.FIND):\n            dom_element = soup.find(**args[scenery.manifest.DomArgument.FIND])\n            django_testcase.assertIsNotNone(\n                dom_element,\n                f\"Expected to find an element matching {args[scenery.manifest.DomArgument.FIND]}, but found none\",\n            )\n            dom_elements = [dom_element]\n        else:\n            raise ValueError(\"Neither find of find_all argument provided\")\n\n        # Perform the additional checks\n        if count := args.get(scenery.manifest.DomArgument.COUNT):\n            django_testcase.assertEqual(\n                len(dom_elements),\n                count,\n                f\"Expected to find {count} elements, but found {len(dom_elements)}\",\n            )\n        for dom_element in dom_elements:\n            if text := args.get(scenery.manifest.DomArgument.TEXT):\n                django_testcase.assertEqual(\n                    dom_element.text,\n                    text,\n                    f\"Expected element text to be '{text}', but got '{dom_element.text}'\",\n                )\n            if attribute := args.get(scenery.manifest.DomArgument.ATTRIBUTE):\n                # TODO: should this move to manifest parser? we will decide in v2\n                match attribute[\"value\"]:\n                    case str(v) | list(v):\n                        pass\n                    case int(n):\n                        attribute[\"value\"] = str(n)\n                    case x:\n                        raise ValueError(\n                            f\"attribute value can only by `str` or `list[str]` not '{type(x)}'\"\n                        )\n                django_testcase.assertEqual(\n                    dom_element[attribute[\"name\"]],\n                    attribute[\"value\"],\n                    f\"Expected attribute '{attribute['name']}' to have value '{attribute['value']}', but got '{dom_element[attribute['name']]}'\",\n                )\n</code></pre>"},{"location":"api/#scenery.http_checker.HttpChecker.check_count_instances","title":"<code>check_count_instances(django_testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check if the count of model instances matches the expected count.</p> <p>Parameters:</p> Name Type Description Default <code>django_testcase</code> <code>TestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>HttpResponse</code> <p>The HTTP response (not used in this check).</p> required <code>args</code> <code>dict</code> <p>A dictionary containing 'model' (the model class) and 'n' (expected count).</p> required Source code in <code>scenery/http_checker.py</code> <pre><code>@staticmethod\ndef check_count_instances(\n    django_testcase: django.test.TestCase,\n    response: django.http.HttpResponse,\n    args: dict,\n):\n    \"\"\"\n    Check if the count of model instances matches the expected count.\n\n    Args:\n        django_testcase (django.test.TestCase): The Django test case instance.\n        response (django.http.HttpResponse): The HTTP response (not used in this check).\n        args (dict): A dictionary containing 'model' (the model class) and 'n' (expected count).\n    \"\"\"\n    instances = list(args[\"model\"].objects.all())\n    django_testcase.assertEqual(\n        len(instances),\n        args[\"n\"],\n        f\"Expected {args['n']} instances of {args['model'].__name__}, but found {len(instances)}\",\n    )\n</code></pre>"},{"location":"api/#scenery.http_checker.HttpChecker.check_dom_element","title":"<code>check_dom_element(django_testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check for the presence and properties of DOM elements in the response content.</p> <p>This method uses BeautifulSoup to parse the response content and perform various checks on DOM elements as specified in the args dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>django_testcase</code> <code>TestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>HttpResponse</code> <p>The HTTP response to check.</p> required <code>args</code> <code>dict</code> <p>A dictionary of DomArgument keys and their corresponding values,          specifying the checks to perform.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither 'find' nor 'find_all' arguments are provided in args.</p> Source code in <code>scenery/http_checker.py</code> <pre><code>@staticmethod\ndef check_dom_element(\n    django_testcase: django.test.TestCase,\n    response: django.http.HttpResponse,\n    args: dict[scenery.manifest.DomArgument, Any],\n):\n    \"\"\"\n    Check for the presence and properties of DOM elements in the response content.\n\n    This method uses BeautifulSoup to parse the response content and perform various\n    checks on DOM elements as specified in the args dictionary.\n\n    Args:\n        django_testcase (django.test.TestCase): The Django test case instance.\n        response (django.http.HttpResponse): The HTTP response to check.\n        args (dict): A dictionary of DomArgument keys and their corresponding values,\n                     specifying the checks to perform.\n\n    Raises:\n        ValueError: If neither 'find' nor 'find_all' arguments are provided in args.\n    \"\"\"\n\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    # Apply the scope\n    if scope := args.get(scenery.manifest.DomArgument.SCOPE):\n        soup = soup.find(**scope)\n\n    # Locate the element(s)\n    # If find_all is provided, the checks are performed on ALL elements\n    # If find is provided we enforce the result to be la list\n    if args.get(scenery.manifest.DomArgument.FIND_ALL):\n        dom_elements = soup.find_all(**args[scenery.manifest.DomArgument.FIND_ALL])\n        django_testcase.assertGreaterEqual(\n            len(dom_elements),\n            1,\n            f\"Expected to find at least one element matching {args[scenery.manifest.DomArgument.FIND_ALL]}, but found none\",\n        )\n    elif args.get(scenery.manifest.DomArgument.FIND):\n        dom_element = soup.find(**args[scenery.manifest.DomArgument.FIND])\n        django_testcase.assertIsNotNone(\n            dom_element,\n            f\"Expected to find an element matching {args[scenery.manifest.DomArgument.FIND]}, but found none\",\n        )\n        dom_elements = [dom_element]\n    else:\n        raise ValueError(\"Neither find of find_all argument provided\")\n\n    # Perform the additional checks\n    if count := args.get(scenery.manifest.DomArgument.COUNT):\n        django_testcase.assertEqual(\n            len(dom_elements),\n            count,\n            f\"Expected to find {count} elements, but found {len(dom_elements)}\",\n        )\n    for dom_element in dom_elements:\n        if text := args.get(scenery.manifest.DomArgument.TEXT):\n            django_testcase.assertEqual(\n                dom_element.text,\n                text,\n                f\"Expected element text to be '{text}', but got '{dom_element.text}'\",\n            )\n        if attribute := args.get(scenery.manifest.DomArgument.ATTRIBUTE):\n            # TODO: should this move to manifest parser? we will decide in v2\n            match attribute[\"value\"]:\n                case str(v) | list(v):\n                    pass\n                case int(n):\n                    attribute[\"value\"] = str(n)\n                case x:\n                    raise ValueError(\n                        f\"attribute value can only by `str` or `list[str]` not '{type(x)}'\"\n                    )\n            django_testcase.assertEqual(\n                dom_element[attribute[\"name\"]],\n                attribute[\"value\"],\n                f\"Expected attribute '{attribute['name']}' to have value '{attribute['value']}', but got '{dom_element[attribute['name']]}'\",\n            )\n</code></pre>"},{"location":"api/#scenery.http_checker.HttpChecker.check_redirect_url","title":"<code>check_redirect_url(django_testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check if the response redirect URL matches the expected URL.</p> <p>Parameters:</p> Name Type Description Default <code>django_testcase</code> <code>TestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>HttpResponseRedirect</code> <p>The HTTP redirect response to check.</p> required <code>args</code> <code>str</code> <p>The expected redirect URL.</p> required Source code in <code>scenery/http_checker.py</code> <pre><code>@staticmethod\ndef check_redirect_url(\n    django_testcase: django.test.TestCase,\n    response: django.http.HttpResponseRedirect,\n    args: str,\n):\n    \"\"\"\n    Check if the response redirect URL matches the expected URL.\n\n    Args:\n        django_testcase (django.test.TestCase): The Django test case instance.\n        response (django.http.HttpResponseRedirect): The HTTP redirect response to check.\n        args (str): The expected redirect URL.\n    \"\"\"\n    django_testcase.assertEqual(\n        response.url,\n        args,\n        f\"Expected redirect URL '{args}', but got '{response.url}'\",\n    )\n</code></pre>"},{"location":"api/#scenery.http_checker.HttpChecker.check_status_code","title":"<code>check_status_code(django_testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check if the response status code matches the expected code.</p> <p>Parameters:</p> Name Type Description Default <code>django_testcase</code> <code>TestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>HttpResponse</code> <p>The HTTP response to check.</p> required <code>args</code> <code>int</code> <p>The expected status code.</p> required Source code in <code>scenery/http_checker.py</code> <pre><code>@staticmethod\ndef check_status_code(\n    django_testcase: django.test.TestCase,\n    response: django.http.HttpResponse,\n    args: int,\n):\n    \"\"\"\n    Check if the response status code matches the expected code.\n\n    Args:\n        django_testcase (django.test.TestCase): The Django test case instance.\n        response (django.http.HttpResponse): The HTTP response to check.\n        args (int): The expected status code.\n    \"\"\"\n    django_testcase.assertEqual(\n        response.status_code,\n        args,\n        f\"Expected status code {args}, but got {response.status_code}\",\n    )\n</code></pre>"},{"location":"api/#scenery.http_checker.HttpChecker.exec_check","title":"<code>exec_check(django_testcase, response, check)</code>  <code>staticmethod</code>","text":"<p>Execute a specific check on an HTTP response.</p> <p>This method delegates to the appropriate check method based on the instruction specified in the HttpCheck object.</p> <p>Parameters:</p> Name Type Description Default <code>django_testcase</code> <code>TestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>HttpResponse</code> <p>The HTTP response to check.</p> required <code>check</code> <code>HttpCheck</code> <p>The check to perform on the response.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the check instruction is not implemented.</p> Source code in <code>scenery/http_checker.py</code> <pre><code>@staticmethod\ndef exec_check(\n    django_testcase: django.test.TestCase,\n    response: django.http.HttpResponse,\n    check: scenery.manifest.HttpCheck,\n):\n    \"\"\"\n    Execute a specific check on an HTTP response.\n\n    This method delegates to the appropriate check method based on the instruction\n    specified in the HttpCheck object.\n\n    Args:\n        django_testcase (django.test.TestCase): The Django test case instance.\n        response (django.http.HttpResponse): The HTTP response to check.\n        check (scenery.manifest.HttpCheck): The check to perform on the response.\n\n    Raises:\n        NotImplementedError: If the check instruction is not implemented.\n    \"\"\"\n    match check.instruction:\n        case scenery.manifest.DirectiveCommand.STATUS_CODE:\n            HttpChecker.check_status_code(django_testcase, response, check.args)\n        case scenery.manifest.DirectiveCommand.REDIRECT_URL:\n            HttpChecker.check_redirect_url(django_testcase, response, check.args)\n        case scenery.manifest.DirectiveCommand.COUNT_INSTANCES:\n            HttpChecker.check_count_instances(django_testcase, response, check.args)\n        case scenery.manifest.DirectiveCommand.DOM_ELEMENT:\n            HttpChecker.check_dom_element(django_testcase, response, check.args)\n        case _:\n            raise NotImplementedError(check)\n</code></pre>"},{"location":"api/#scenery.http_checker.HttpChecker.get_http_client_response","title":"<code>get_http_client_response(client, take)</code>  <code>staticmethod</code>","text":"<p>Execute an HTTP request based on the given HttpTake object.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>The Django test client to use for the request.</p> required <code>take</code> <code>HttpTake</code> <p>The HttpTake object specifying the request details.</p> required <p>Returns:</p> Type Description <p>django.http.HttpResponse: The response from the HTTP request.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the HTTP method specified in the take is not implemented.</p> Source code in <code>scenery/http_checker.py</code> <pre><code>@staticmethod\ndef get_http_client_response(client, take: scenery.manifest.HttpTake):\n    \"\"\"\n    Execute an HTTP request based on the given HttpTake object.\n\n    Args:\n        client: The Django test client to use for the request.\n        take (scenery.manifest.HttpTake): The HttpTake object specifying the request details.\n\n    Returns:\n        django.http.HttpResponse: The response from the HTTP request.\n\n    Raises:\n        NotImplementedError: If the HTTP method specified in the take is not implemented.\n    \"\"\"\n\n    match take.method:\n        case http.HTTPMethod.GET:\n            response = client.get(\n                take.url,\n                take.data,\n            )\n        case http.HTTPMethod.POST:\n            response = client.post(\n                take.url,\n                take.data,\n            )\n        case _:\n            raise NotImplementedError(take.method)\n\n    return response\n</code></pre>"},{"location":"api/#manifest-parser","title":"Manifest Parser","text":""},{"location":"api/#scenery.manifest_parser.ManifestParser","title":"<code>ManifestParser</code>","text":"<p>A class responsible for parsing test manifest files in YAML format.</p> <p>This class provides methods to validate, format, and parse manifest files into Python objects that can be used by the testing framework.</p> <p>Attributes:</p> Name Type Description <code>common_items</code> <code>dict</code> <p>Common items loaded from a YAML file specified by the SCENERY_COMMON_ITEMS environment variable.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>class ManifestParser:\n    \"\"\"\n    A class responsible for parsing test manifest files in YAML format.\n\n    This class provides methods to validate, format, and parse manifest files\n    into Python objects that can be used by the testing framework.\n\n    Attributes:\n        common_items (dict): Common items loaded from a YAML file specified by the SCENERY_COMMON_ITEMS environment variable.\n    \"\"\"\n\n    common_items = scenery.common.read_yaml(os.getenv(\"SCENERY_COMMON_ITEMS\"))\n\n    ################\n    # FORMATTED DICT\n    ################\n\n    @staticmethod\n    def parse_formatted_dict(d: dict):\n        \"\"\"\n        Parse a dictionary with all expected keys into a Manifest object.\n\n        Args:\n            d (dict): A dictionary containing the manifest data with all expected keys.\n                - set_up_test_data\n                - set_up\n                - cases\n                - scenes\n                - manifest_origin\n\n        Returns:\n            scenery.manifest.Manifest: A Manifest object created from the input dictionary.\n        \"\"\"\n\n        d = {key: d[key.value] for key in scenery.manifest.ManifestFormattedDictKeys}\n        return scenery.manifest.Manifest.from_formatted_dict(d)\n\n    ##########\n    # ANY DICT\n    ##########\n\n    @staticmethod\n    def validate_dict(d: dict):\n        \"\"\"\n        Validate the top-level keys of a manifest dictionary.\n\n        This method checks if only valid keys are present at the top level and ensures\n        that either singular or plural forms of 'case' and 'scene' are provided, but not both.\n\n        Args:\n            d (dict): The manifest dictionary to validate.\n\n        Raises:\n            ValueError: If invalid keys are present or if the case/scene keys are not correctly specified.\n        \"\"\"\n\n        if not all(key in [x.value for x in scenery.manifest.ManifestDictKeys] for key in d.keys()):\n            raise ValueError(\n                f\"Invalid key(s) in {d.keys()} ({d.get('manifest_origin', 'No origin found.')}).\"\n            )\n\n        for key in [\"case\", \"scene\"]:\n            has_one = key in d\n            has_many = f\"{key}s\" in d\n\n            if has_one and has_many:\n                raise ValueError(\n                    f\"Both `{key}` and `{key}s` keys are present at top level.\",\n                )\n\n            if key == \"scene\" and not (has_one or has_many):\n                raise ValueError(\n                    f\"Neither `{key}` and `{key}s` keys are present at top level.\",\n                )\n\n    @staticmethod\n    def format_dict(manifest: dict) -&gt; dict:\n        \"\"\"\n        Reformat the manifest dictionary to ensure it has all expected keys and provide default values if needed.\n\n        Args:\n            manifest (dict): The original manifest dictionary.\n\n        Returns:\n            dict: A formatted dictionary with all expected keys.\n        \"\"\"\n        return {\n            \"set_up_test_data\": manifest.get(\"set_up_test_data\", []),\n            \"set_up\": manifest.get(\"set_up\", []),\n            \"scenes\": ManifestParser._format_dict_scenes(manifest),\n            \"cases\": ManifestParser._format_dict_cases(manifest),\n            \"manifest_origin\": manifest[\"manifest_origin\"],\n        }\n\n    @staticmethod\n    def _format_dict_cases(d: dict) -&gt; dict[str, dict]:\n        has_one = \"case\" in d\n        has_many = \"cases\" in d\n        if has_one:\n            return {\"CASE\": d[\"case\"]}\n        elif has_many:\n            return d[\"cases\"]\n        else:\n            return {\"NO_CASE\": {}}\n\n    @staticmethod\n    def _format_dict_scenes(d: dict) -&gt; list[dict]:\n        has_one = \"scene\" in d\n        has_many = \"scenes\" in d\n        if has_one:\n            return [d[\"scene\"]]\n        elif has_many:\n            return d[\"scenes\"]\n\n    @staticmethod\n    def parse_dict(d: dict):\n        \"\"\"\n        Parse a manifest dictionary into a Manifest object.\n\n        This method validates the dictionary, formats it, and then parses it into a Manifest object.\n\n        Args:\n            d (dict): The manifest dictionary to parse.\n\n        Returns:\n            scenery.manifest.Manifest: A Manifest object created from the input dictionary.\n        \"\"\"\n        ManifestParser.validate_dict(d)\n        d = ManifestParser.format_dict(d)\n        return ManifestParser.parse_formatted_dict(d)\n\n    ##########\n    # YAML\n    ##########\n\n    @staticmethod\n    def validate_yaml(yaml):\n        \"\"\"\n        Validate the structure of a YAML-loaded manifest.\n\n        This method checks if the YAML content is a dictionary and if it contains only expected keys.\n\n        Args:\n            yaml: The YAML content to validate.\n\n        Raises:\n            TypeError: If the YAML content is not a dictionary.\n            ValueError: If the YAML content contains unexpected keys.\n        \"\"\"\n\n        if type(yaml) is not dict:\n            raise TypeError(f\"Manifest need to be a dict not a '{type(yaml)}'\")\n\n        if not all(\n            key in [x.value for x in scenery.manifest.ManifestYAMLKeys] for key in yaml.keys()\n        ):\n            raise ValueError(\n                f\"Invalid key(s) in {yaml.keys()} ({yaml.get('origin', 'No origin found.')})\"\n            )\n\n    @staticmethod\n    def _yaml_constructor_case(loader: yaml.SafeLoader, node: yaml.nodes.Node):\n        if isinstance(node, yaml.nodes.ScalarNode):\n            return scenery.manifest.Substituable(loader.construct_scalar(node))\n        else:\n            raise ConstructorError\n\n    @staticmethod\n    def _yaml_constructor_common_item(loader: yaml.SafeLoader, node: yaml.nodes.Node):\n        if isinstance(node, yaml.nodes.ScalarNode):\n            return ManifestParser.common_items[loader.construct_scalar(node)]\n        if isinstance(node, yaml.nodes.MappingNode):\n            d = loader.construct_mapping(node)\n            case = ManifestParser.common_items[d[\"ID\"]] | {\n                key: value for key, value in d.items() if key != \"ID\"\n            }\n            return case\n        else:\n            raise ConstructorError\n\n    @staticmethod\n    def read_manifest_yaml(fn):\n        \"\"\"\n        Read a YAML manifest file with custom tags.\n\n        This method uses a custom YAML loader to handle special tags like !case and !common-item.\n\n        Args:\n            fn (str): The filename of the YAML manifest to read.\n\n        Returns:\n            dict: The parsed content of the YAML file.\n        \"\"\"\n\n        # NOTE: inspired by https://matthewpburruss.com/post/yaml/\n\n        # Add constructor\n        Loader = yaml.FullLoader\n        Loader.add_constructor(\"!case\", ManifestParser._yaml_constructor_case)\n        Loader.add_constructor(\"!common-item\", ManifestParser._yaml_constructor_common_item)\n\n        with open(fn) as f:\n            content = yaml.load(f, Loader)\n\n        return content\n\n    @staticmethod\n    def parse_yaml(filename):\n        \"\"\"\n        Parse a YAML manifest file into a Manifest object.\n\n        This method reads the YAML file, validates its content, and then parses it into a Manifest object.\n\n        Args:\n            filename (str): The filename of the YAML manifest to parse.\n\n        Returns:\n            scenery.manifest.Manifest: A Manifest object created from the YAML file.\n        \"\"\"\n        d = ManifestParser.read_manifest_yaml(filename)\n        ManifestParser.validate_yaml(d)\n        d[\"manifest_origin\"] = d.get(\"manifest_origin\", filename)\n        if \"variables\" in d:\n            del d[\"variables\"]\n        return ManifestParser.parse_dict(d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.format_dict","title":"<code>format_dict(manifest)</code>  <code>staticmethod</code>","text":"<p>Reformat the manifest dictionary to ensure it has all expected keys and provide default values if needed.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>dict</code> <p>The original manifest dictionary.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A formatted dictionary with all expected keys.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef format_dict(manifest: dict) -&gt; dict:\n    \"\"\"\n    Reformat the manifest dictionary to ensure it has all expected keys and provide default values if needed.\n\n    Args:\n        manifest (dict): The original manifest dictionary.\n\n    Returns:\n        dict: A formatted dictionary with all expected keys.\n    \"\"\"\n    return {\n        \"set_up_test_data\": manifest.get(\"set_up_test_data\", []),\n        \"set_up\": manifest.get(\"set_up\", []),\n        \"scenes\": ManifestParser._format_dict_scenes(manifest),\n        \"cases\": ManifestParser._format_dict_cases(manifest),\n        \"manifest_origin\": manifest[\"manifest_origin\"],\n    }\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.parse_dict","title":"<code>parse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Parse a manifest dictionary into a Manifest object.</p> <p>This method validates the dictionary, formats it, and then parses it into a Manifest object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The manifest dictionary to parse.</p> required <p>Returns:</p> Type Description <p>scenery.manifest.Manifest: A Manifest object created from the input dictionary.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef parse_dict(d: dict):\n    \"\"\"\n    Parse a manifest dictionary into a Manifest object.\n\n    This method validates the dictionary, formats it, and then parses it into a Manifest object.\n\n    Args:\n        d (dict): The manifest dictionary to parse.\n\n    Returns:\n        scenery.manifest.Manifest: A Manifest object created from the input dictionary.\n    \"\"\"\n    ManifestParser.validate_dict(d)\n    d = ManifestParser.format_dict(d)\n    return ManifestParser.parse_formatted_dict(d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.parse_formatted_dict","title":"<code>parse_formatted_dict(d)</code>  <code>staticmethod</code>","text":"<p>Parse a dictionary with all expected keys into a Manifest object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>A dictionary containing the manifest data with all expected keys. - set_up_test_data - set_up - cases - scenes - manifest_origin</p> required <p>Returns:</p> Type Description <p>scenery.manifest.Manifest: A Manifest object created from the input dictionary.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef parse_formatted_dict(d: dict):\n    \"\"\"\n    Parse a dictionary with all expected keys into a Manifest object.\n\n    Args:\n        d (dict): A dictionary containing the manifest data with all expected keys.\n            - set_up_test_data\n            - set_up\n            - cases\n            - scenes\n            - manifest_origin\n\n    Returns:\n        scenery.manifest.Manifest: A Manifest object created from the input dictionary.\n    \"\"\"\n\n    d = {key: d[key.value] for key in scenery.manifest.ManifestFormattedDictKeys}\n    return scenery.manifest.Manifest.from_formatted_dict(d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.parse_yaml","title":"<code>parse_yaml(filename)</code>  <code>staticmethod</code>","text":"<p>Parse a YAML manifest file into a Manifest object.</p> <p>This method reads the YAML file, validates its content, and then parses it into a Manifest object.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the YAML manifest to parse.</p> required <p>Returns:</p> Type Description <p>scenery.manifest.Manifest: A Manifest object created from the YAML file.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef parse_yaml(filename):\n    \"\"\"\n    Parse a YAML manifest file into a Manifest object.\n\n    This method reads the YAML file, validates its content, and then parses it into a Manifest object.\n\n    Args:\n        filename (str): The filename of the YAML manifest to parse.\n\n    Returns:\n        scenery.manifest.Manifest: A Manifest object created from the YAML file.\n    \"\"\"\n    d = ManifestParser.read_manifest_yaml(filename)\n    ManifestParser.validate_yaml(d)\n    d[\"manifest_origin\"] = d.get(\"manifest_origin\", filename)\n    if \"variables\" in d:\n        del d[\"variables\"]\n    return ManifestParser.parse_dict(d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.read_manifest_yaml","title":"<code>read_manifest_yaml(fn)</code>  <code>staticmethod</code>","text":"<p>Read a YAML manifest file with custom tags.</p> <p>This method uses a custom YAML loader to handle special tags like !case and !common-item.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>str</code> <p>The filename of the YAML manifest to read.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The parsed content of the YAML file.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef read_manifest_yaml(fn):\n    \"\"\"\n    Read a YAML manifest file with custom tags.\n\n    This method uses a custom YAML loader to handle special tags like !case and !common-item.\n\n    Args:\n        fn (str): The filename of the YAML manifest to read.\n\n    Returns:\n        dict: The parsed content of the YAML file.\n    \"\"\"\n\n    # NOTE: inspired by https://matthewpburruss.com/post/yaml/\n\n    # Add constructor\n    Loader = yaml.FullLoader\n    Loader.add_constructor(\"!case\", ManifestParser._yaml_constructor_case)\n    Loader.add_constructor(\"!common-item\", ManifestParser._yaml_constructor_common_item)\n\n    with open(fn) as f:\n        content = yaml.load(f, Loader)\n\n    return content\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.validate_dict","title":"<code>validate_dict(d)</code>  <code>staticmethod</code>","text":"<p>Validate the top-level keys of a manifest dictionary.</p> <p>This method checks if only valid keys are present at the top level and ensures that either singular or plural forms of 'case' and 'scene' are provided, but not both.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The manifest dictionary to validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid keys are present or if the case/scene keys are not correctly specified.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef validate_dict(d: dict):\n    \"\"\"\n    Validate the top-level keys of a manifest dictionary.\n\n    This method checks if only valid keys are present at the top level and ensures\n    that either singular or plural forms of 'case' and 'scene' are provided, but not both.\n\n    Args:\n        d (dict): The manifest dictionary to validate.\n\n    Raises:\n        ValueError: If invalid keys are present or if the case/scene keys are not correctly specified.\n    \"\"\"\n\n    if not all(key in [x.value for x in scenery.manifest.ManifestDictKeys] for key in d.keys()):\n        raise ValueError(\n            f\"Invalid key(s) in {d.keys()} ({d.get('manifest_origin', 'No origin found.')}).\"\n        )\n\n    for key in [\"case\", \"scene\"]:\n        has_one = key in d\n        has_many = f\"{key}s\" in d\n\n        if has_one and has_many:\n            raise ValueError(\n                f\"Both `{key}` and `{key}s` keys are present at top level.\",\n            )\n\n        if key == \"scene\" and not (has_one or has_many):\n            raise ValueError(\n                f\"Neither `{key}` and `{key}s` keys are present at top level.\",\n            )\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.validate_yaml","title":"<code>validate_yaml(yaml)</code>  <code>staticmethod</code>","text":"<p>Validate the structure of a YAML-loaded manifest.</p> <p>This method checks if the YAML content is a dictionary and if it contains only expected keys.</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <p>The YAML content to validate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the YAML content is not a dictionary.</p> <code>ValueError</code> <p>If the YAML content contains unexpected keys.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef validate_yaml(yaml):\n    \"\"\"\n    Validate the structure of a YAML-loaded manifest.\n\n    This method checks if the YAML content is a dictionary and if it contains only expected keys.\n\n    Args:\n        yaml: The YAML content to validate.\n\n    Raises:\n        TypeError: If the YAML content is not a dictionary.\n        ValueError: If the YAML content contains unexpected keys.\n    \"\"\"\n\n    if type(yaml) is not dict:\n        raise TypeError(f\"Manifest need to be a dict not a '{type(yaml)}'\")\n\n    if not all(\n        key in [x.value for x in scenery.manifest.ManifestYAMLKeys] for key in yaml.keys()\n    ):\n        raise ValueError(\n            f\"Invalid key(s) in {yaml.keys()} ({yaml.get('origin', 'No origin found.')})\"\n        )\n</code></pre>"},{"location":"api/#manifest","title":"Manifest","text":"<p>Represent all data conveied by the manifest</p>"},{"location":"api/#scenery.manifest.Case","title":"<code>Case</code>  <code>dataclass</code>","text":"<p>Store a collection of items representing a test case.</p> <p>Attributes:</p> Name Type Description <code>_id</code> <code>str</code> <p>The identifier for this case.</p> <code>items</code> <code>dict[str, Item]</code> <p>A dictionary of items in this case, indexed by item ID.</p> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Retrieve an item from the case by its ID.</p> Class Methods <p>from_id_and_dict(case_id: str, items: dict[str, dict]) -&gt; Case:     Create a Case instance from a case ID and a dictionary of items.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass Case:\n    \"\"\"\n    Store a collection of items representing a test case.\n\n    Attributes:\n        _id (str): The identifier for this case.\n        items (dict[str, Item]): A dictionary of items in this case, indexed by item ID.\n\n    Methods:\n        __getitem__(item_id): Retrieve an item from the case by its ID.\n\n    Class Methods:\n        from_id_and_dict(case_id: str, items: dict[str, dict]) -&gt; Case:\n            Create a Case instance from a case ID and a dictionary of items.\n    \"\"\"\n\n    _id: str\n    items: dict[str, Item]\n\n    def __getitem__(self, item_id: str) -&gt; Item:\n        return self.items[item_id]\n\n    @classmethod\n    def from_id_and_dict(cls, case_id: str, items: dict[str, dict[str, Any]]) -&gt; \"Case\":\n        items = {item_id: Item(item_id, item_dict) for item_id, item_dict in items.items()}\n        return cls(case_id, items)\n</code></pre>"},{"location":"api/#scenery.manifest.DirectiveCommand","title":"<code>DirectiveCommand</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Values allowed for Manifest[\"checks\"]</p> Source code in <code>scenery/manifest.py</code> <pre><code>class DirectiveCommand(enum.Enum):\n    \"\"\"Values allowed for Manifest[\"checks\"]\"\"\"\n\n    STATUS_CODE = \"status_code\"\n    REDIRECT_URL = \"redirect_url\"\n    COUNT_INSTANCES = \"count_instances\"\n    DOM_ELEMENT = \"dom_element\"\n</code></pre>"},{"location":"api/#scenery.manifest.DomArgument","title":"<code>DomArgument</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Values allowed for Manifest\"checks</p> Source code in <code>scenery/manifest.py</code> <pre><code>class DomArgument(enum.Enum):\n    \"\"\"Values allowed for Manifest[\"checks][\"dom_element\"]\"\"\"\n\n    FIND = \"find\"\n    FIND_ALL = \"find_all\"\n    COUNT = \"count\"\n    SCOPE = \"scope\"\n    TEXT = \"text\"\n    ATTRIBUTE = \"attribute\"\n</code></pre>"},{"location":"api/#scenery.manifest.HttpCheck","title":"<code>HttpCheck</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HttpDirective</code></p> <p>Store a given check to perform (after the subsitution)</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass HttpCheck(HttpDirective):\n    \"\"\"Store a given check to perform (after the subsitution)\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Format self.args\"\"\"\n\n        match self.instruction, self.args:\n            case DirectiveCommand.STATUS_CODE, int(n):\n                self.args = http.HTTPStatus(n)\n            case DirectiveCommand.DOM_ELEMENT, dict(d):\n                self.args = {DomArgument(key): value for key, value in d.items()}\n                if attribute := self.args.get(DomArgument.ATTRIBUTE):\n                    self.args[DomArgument.ATTRIBUTE][\"value\"] = (\n                        self._format_dom_element_attribute_value(attribute[\"value\"])\n                    )\n            case DirectiveCommand.REDIRECT_URL, str(s):\n                pass\n            case DirectiveCommand.COUNT_INSTANCES, {\"model\": ModelBase(), \"n\": int(n)}:\n                # Validate model is registered\n                app_config = django_apps.get_app_config(os.getenv(\"SCENERY_TESTED_APP_NAME\"))\n                app_config.get_model(self.args[\"model\"].__name__)\n            case _:\n                raise ValueError(\n                    f\"Cannot interpret '{self.instruction}:({self.args})' as Directive\"\n                )\n\n    @staticmethod\n    def _format_dom_element_attribute_value(value: str | int | list[str]) -&gt; list[str] | str:\n        match value:\n            case str(s):\n                return value\n            case list(l):\n                return value\n            case int(n):\n                return str(n)\n            case x:\n                raise ValueError(\n                    f\"attribute value can only be `str` or `list[str]` not {x} ('{type(x)}')\"\n                )\n</code></pre>"},{"location":"api/#scenery.manifest.HttpCheck.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Format self.args</p> Source code in <code>scenery/manifest.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Format self.args\"\"\"\n\n    match self.instruction, self.args:\n        case DirectiveCommand.STATUS_CODE, int(n):\n            self.args = http.HTTPStatus(n)\n        case DirectiveCommand.DOM_ELEMENT, dict(d):\n            self.args = {DomArgument(key): value for key, value in d.items()}\n            if attribute := self.args.get(DomArgument.ATTRIBUTE):\n                self.args[DomArgument.ATTRIBUTE][\"value\"] = (\n                    self._format_dom_element_attribute_value(attribute[\"value\"])\n                )\n        case DirectiveCommand.REDIRECT_URL, str(s):\n            pass\n        case DirectiveCommand.COUNT_INSTANCES, {\"model\": ModelBase(), \"n\": int(n)}:\n            # Validate model is registered\n            app_config = django_apps.get_app_config(os.getenv(\"SCENERY_TESTED_APP_NAME\"))\n            app_config.get_model(self.args[\"model\"].__name__)\n        case _:\n            raise ValueError(\n                f\"Cannot interpret '{self.instruction}:({self.args})' as Directive\"\n            )\n</code></pre>"},{"location":"api/#scenery.manifest.HttpDirective","title":"<code>HttpDirective</code>  <code>dataclass</code>","text":"<p>Store a given check to perform, before the substitution (this is part of a Scene, not a Take).</p> <p>This class represents a directive (check) to be performed on an HTTP response, before case-specific substitutions have been made.</p> <p>Attributes:</p> Name Type Description <code>instruction</code> <code>DirectiveCommand</code> <p>The type of check to perform.</p> <code>args</code> <code>Any</code> <p>The arguments for the check.</p> Class Methods <p>from_dict(directive_dict: dict) -&gt; HttpDirective:     Create an HttpDirective instance from a dictionary.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass HttpDirective:\n    \"\"\"\n    Store a given check to perform, before the substitution (this is part of a Scene, not a Take).\n\n    This class represents a directive (check) to be performed on an HTTP response,\n    before case-specific substitutions have been made.\n\n    Attributes:\n        instruction (DirectiveCommand): The type of check to perform.\n        args (Any): The arguments for the check.\n\n    Class Methods:\n        from_dict(directive_dict: dict) -&gt; HttpDirective:\n            Create an HttpDirective instance from a dictionary.\n    \"\"\"\n\n    instruction: DirectiveCommand\n    args: Any\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Format self.args\"\"\"\n\n        match self.instruction, self.args:\n            case DirectiveCommand.STATUS_CODE, int(n):\n                self.args = http.HTTPStatus(n)\n                # NOTE: Workaround if we want the class to be frozen\n                # object.__setattr__(self, \"args\", HTTPStatus(n))\n                pass\n            case DirectiveCommand.STATUS_CODE, Substituable():\n                pass\n            case DirectiveCommand.DOM_ELEMENT, dict(d):\n                self.args = {DomArgument(key): value for key, value in d.items()}\n                # Check if there is and only one locator\n                locators = [\n                    self.args.get(key, None) for key in (DomArgument.FIND_ALL, DomArgument.FIND)\n                ]\n                if not any(locators):\n                    raise ValueError(\"Neither `find_all` or `find` provided to check DOM element\")\n                else:\n                    locators = list(filter(None, locators))\n                    if len(locators) &gt; 1:\n                        raise ValueError(\"More than one locator provided\")\n\n            case DirectiveCommand.DOM_ELEMENT, Substituable():\n                pass\n            case DirectiveCommand.REDIRECT_URL, str(s):\n                pass\n            case DirectiveCommand.REDIRECT_URL, Substituable():\n                pass\n            case DirectiveCommand.COUNT_INSTANCES, {\"model\": str(s), \"n\": int(n)}:\n                app_config = django_apps.get_app_config(os.getenv(\"SCENERY_TESTED_APP_NAME\"))\n                self.args[\"model\"] = app_config.get_model(s)\n            case DirectiveCommand.COUNT_INSTANCES, Substituable():\n                pass\n            case _:\n                raise ValueError(\n                    f\"Cannot interpret '{self.instruction}:({self.args})' as Directive\"\n                )\n\n    @classmethod\n    def from_dict(cls, directive_dict: dict) -&gt; \"HttpDirective\":\n        instruction, args = SingleKeyDict(directive_dict).as_tuple()\n        return cls(DirectiveCommand(instruction), args)\n</code></pre>"},{"location":"api/#scenery.manifest.HttpDirective.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Format self.args</p> Source code in <code>scenery/manifest.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Format self.args\"\"\"\n\n    match self.instruction, self.args:\n        case DirectiveCommand.STATUS_CODE, int(n):\n            self.args = http.HTTPStatus(n)\n            # NOTE: Workaround if we want the class to be frozen\n            # object.__setattr__(self, \"args\", HTTPStatus(n))\n            pass\n        case DirectiveCommand.STATUS_CODE, Substituable():\n            pass\n        case DirectiveCommand.DOM_ELEMENT, dict(d):\n            self.args = {DomArgument(key): value for key, value in d.items()}\n            # Check if there is and only one locator\n            locators = [\n                self.args.get(key, None) for key in (DomArgument.FIND_ALL, DomArgument.FIND)\n            ]\n            if not any(locators):\n                raise ValueError(\"Neither `find_all` or `find` provided to check DOM element\")\n            else:\n                locators = list(filter(None, locators))\n                if len(locators) &gt; 1:\n                    raise ValueError(\"More than one locator provided\")\n\n        case DirectiveCommand.DOM_ELEMENT, Substituable():\n            pass\n        case DirectiveCommand.REDIRECT_URL, str(s):\n            pass\n        case DirectiveCommand.REDIRECT_URL, Substituable():\n            pass\n        case DirectiveCommand.COUNT_INSTANCES, {\"model\": str(s), \"n\": int(n)}:\n            app_config = django_apps.get_app_config(os.getenv(\"SCENERY_TESTED_APP_NAME\"))\n            self.args[\"model\"] = app_config.get_model(s)\n        case DirectiveCommand.COUNT_INSTANCES, Substituable():\n            pass\n        case _:\n            raise ValueError(\n                f\"Cannot interpret '{self.instruction}:({self.args})' as Directive\"\n            )\n</code></pre>"},{"location":"api/#scenery.manifest.HttpScene","title":"<code>HttpScene</code>  <code>dataclass</code>","text":"<p>Store all actions to perform, before the substitution of information from the <code>Cases</code>.</p> <p>This class represents an HTTP scene, which includes the method, URL, and various parameters and checks to be performed.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>HTTPMethod</code> <p>The HTTP method for this scene.</p> <code>url</code> <code>str</code> <p>The URL or URL pattern for this scene.</p> <code>directives</code> <code>list[HttpDirective]</code> <p>The list of directives (checks) to perform.</p> <code>data</code> <code>dict[str, Any]</code> <p>The data to be sent with the request.</p> <code>query_parameters</code> <code>dict</code> <p>Query parameters for the URL.</p> <code>url_parameters</code> <code>dict</code> <p>URL parameters for reverse URL lookup.</p> <p>Methods:</p> Name Description <code>shoot</code> <p>Case) -&gt; HttpTake: Create an HttpTake instance by substituting case values into the scene.</p> Class Methods <p>from_dict(d: dict) -&gt; HttpScene:     Create an HttpScene instance from a dictionary. substitute_recursively(x, case: Case):     Recursively substitute values from a case into a data structure.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass HttpScene:\n    \"\"\"\n    Store all actions to perform, before the substitution of information from the `Cases`.\n\n    This class represents an HTTP scene, which includes the method, URL, and various\n    parameters and checks to be performed.\n\n    Attributes:\n        method (http.HTTPMethod): The HTTP method for this scene.\n        url (str): The URL or URL pattern for this scene.\n        directives (list[HttpDirective]): The list of directives (checks) to perform.\n        data (dict[str, Any]): The data to be sent with the request.\n        query_parameters (dict): Query parameters for the URL.\n        url_parameters (dict): URL parameters for reverse URL lookup.\n\n    Methods:\n        shoot(case: Case) -&gt; HttpTake:\n            Create an HttpTake instance by substituting case values into the scene.\n\n    Class Methods:\n        from_dict(d: dict) -&gt; HttpScene:\n            Create an HttpScene instance from a dictionary.\n        substitute_recursively(x, case: Case):\n            Recursively substitute values from a case into a data structure.\n    \"\"\"\n\n    method: http.HTTPMethod\n    url: str\n    directives: list[HttpDirective]\n    data: dict[str, Any] = field(default_factory=dict)\n    query_parameters: dict = field(default_factory=dict)\n    url_parameters: dict = field(default_factory=dict)\n\n    def __post_init__(self) -&gt; None:\n        self.method = http.HTTPMethod(self.method)\n        # At this point we don't check url as we wait for subsitution\n        # potentially occuring through data/query_parameters/url_parameters\n\n    @classmethod\n    def from_dict(cls, d: dict) -&gt; \"HttpScene\":\n        d[\"directives\"] = [HttpDirective.from_dict(directive) for directive in d[\"directives\"]]\n        return cls(**d)\n\n    @classmethod\n    def substitute_recursively(cls, x: typing.Any, case: Case) -&gt; typing.Any:\n        \"\"\"Perform the substitution\"\"\"\n\n        match x:\n            case int(_) | str(_):\n                return x\n            case ModelBase():\n                return x\n            case Substituable(_):\n                return x.shoot(case)\n            case HttpDirective(instruction, args):\n                return HttpCheck(instruction, cls.substitute_recursively(args, case))\n            case dict(_):\n                return {key: cls.substitute_recursively(value, case) for key, value in x.items()}\n            case list(_):\n                return [cls.substitute_recursively(value, case) for value in x]\n            case _:\n                raise NotImplementedError(f\"Cannot substitute recursively '{x}' ('{type(x)}')\")\n\n    def shoot(self, case: Case) -&gt; \"HttpTake\":\n        return HttpTake(\n            method=self.method,\n            url=self.url,\n            query_parameters=self.query_parameters,\n            data=self.substitute_recursively(self.data, case),\n            url_parameters=self.substitute_recursively(self.url_parameters, case),\n            checks=self.substitute_recursively(self.directives, case),\n        )\n</code></pre>"},{"location":"api/#scenery.manifest.HttpScene.substitute_recursively","title":"<code>substitute_recursively(x, case)</code>  <code>classmethod</code>","text":"<p>Perform the substitution</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef substitute_recursively(cls, x: typing.Any, case: Case) -&gt; typing.Any:\n    \"\"\"Perform the substitution\"\"\"\n\n    match x:\n        case int(_) | str(_):\n            return x\n        case ModelBase():\n            return x\n        case Substituable(_):\n            return x.shoot(case)\n        case HttpDirective(instruction, args):\n            return HttpCheck(instruction, cls.substitute_recursively(args, case))\n        case dict(_):\n            return {key: cls.substitute_recursively(value, case) for key, value in x.items()}\n        case list(_):\n            return [cls.substitute_recursively(value, case) for value in x]\n        case _:\n            raise NotImplementedError(f\"Cannot substitute recursively '{x}' ('{type(x)}')\")\n</code></pre>"},{"location":"api/#scenery.manifest.HttpTake","title":"<code>HttpTake</code>  <code>dataclass</code>","text":"<p>Store all the information after the substitution from the <code>Cases</code> has been performed.</p> <p>This class represents a fully resolved HTTP request to be executed, including the method, URL, data, and checks to be performed.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>HTTPMethod</code> <p>The HTTP method for this take.</p> <code>url</code> <code>str</code> <p>The fully resolved URL for this take.</p> <code>checks</code> <code>list[HttpCheck]</code> <p>The list of checks to perform on the response.</p> <code>data</code> <code>dict</code> <p>The data to be sent with the request.</p> <code>query_parameters</code> <code>dict</code> <p>Query parameters for the URL.</p> <code>url_parameters</code> <code>dict</code> <p>URL parameters used in URL resolution.</p> Notes <p>The <code>url</code> is expected to be either a valid URL or a registered viewname. If it's a viewname, it will be resolved using Django's <code>reverse</code> function.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass HttpTake:\n    \"\"\"\n    Store all the information after the substitution from the `Cases` has been performed.\n\n    This class represents a fully resolved HTTP request to be executed, including\n    the method, URL, data, and checks to be performed.\n\n    Attributes:\n        method (http.HTTPMethod): The HTTP method for this take.\n        url (str): The fully resolved URL for this take.\n        checks (list[HttpCheck]): The list of checks to perform on the response.\n        data (dict): The data to be sent with the request.\n        query_parameters (dict): Query parameters for the URL.\n        url_parameters (dict): URL parameters used in URL resolution.\n\n    Notes:\n        The `url` is expected to be either a valid URL or a registered viewname.\n        If it's a viewname, it will be resolved using Django's `reverse` function.\n    \"\"\"\n\n    method: http.HTTPMethod\n    url: str\n    checks: list[HttpCheck]\n    data: dict\n    query_parameters: dict\n    url_parameters: dict\n\n    def __post_init__(self) -&gt; None:\n        self.method = http.HTTPMethod(self.method)\n\n        try:\n            # First we try if the url is a django viewname\n            self.url = reverse(self.url, kwargs=self.url_parameters)\n        except NoReverseMatch:\n            # Otherwise we check it is a valid url\n            parsed = urlparse(self.url)\n            if not (parsed.scheme and parsed.netloc):\n                raise ValueError(f\"'{self.url}' could not be reversed and is not a valid url\")\n\n        if self.query_parameters:\n            # NOTE: We use http.urlencode instead for compatibility\n            # https://stackoverflow.com/questions/4995279/including-a-querystring-in-a-django-core-urlresolvers-reverse-call\n            # https://gist.github.com/benbacardi/227f924ec1d9bedd242b\n            self.url += \"?\" + urlencode(self.query_parameters)\n</code></pre>"},{"location":"api/#scenery.manifest.Item","title":"<code>Item</code>  <code>dataclass</code>","text":"<p>Store potential information that will be used to build the HttpRequest</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass Item:\n    \"\"\"Store potential information that will be used to build the HttpRequest\"\"\"\n\n    _id: str\n    _dict: dict[str, Any]\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self._dict[key]\n</code></pre>"},{"location":"api/#scenery.manifest.Manifest","title":"<code>Manifest</code>  <code>dataclass</code>","text":"<p>Store all the information to build/shoot all different <code>Takes</code>.</p> <p>This class represents a complete test manifest, including setup instructions, test cases, and scenes to be executed.</p> <p>Attributes:</p> Name Type Description <code>set_up_test_data</code> <code>list[SetUpInstruction]</code> <p>Instructions for setting up test data.</p> <code>set_up</code> <code>list[SetUpInstruction]</code> <p>Instructions for general test setup.</p> <code>scenes</code> <code>list[HttpScene]</code> <p>The HTTP scenes to be executed.</p> <code>cases</code> <code>dict[str, Case]</code> <p>The test cases, indexed by case ID.</p> <code>manifest_origin</code> <code>str</code> <p>The origin of the manifest file.</p> Class Methods <p>from_formatted_dict(d: dict) -&gt; Manifest:     Create a Manifest instance from a formatted dictionary.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass Manifest:\n    \"\"\"\n    Store all the information to build/shoot all different `Takes`.\n\n    This class represents a complete test manifest, including setup instructions,\n    test cases, and scenes to be executed.\n\n    Attributes:\n        set_up_test_data (list[SetUpInstruction]): Instructions for setting up test data.\n        set_up (list[SetUpInstruction]): Instructions for general test setup.\n        scenes (list[HttpScene]): The HTTP scenes to be executed.\n        cases (dict[str, Case]): The test cases, indexed by case ID.\n        manifest_origin (str): The origin of the manifest file.\n\n    Class Methods:\n        from_formatted_dict(d: dict) -&gt; Manifest:\n            Create a Manifest instance from a formatted dictionary.\n    \"\"\"\n\n    set_up_test_data: list[SetUpInstruction]\n    set_up: list[SetUpInstruction]\n    scenes: list[HttpScene]\n    cases: dict[str, Case]\n    manifest_origin: str\n\n    @classmethod\n    def from_formatted_dict(cls, d: dict) -&gt; \"Manifest\":\n        return cls(\n            [\n                SetUpInstruction.from_object(instruction)\n                for instruction in d[ManifestFormattedDictKeys.SET_UP_TEST_DATA]\n            ],\n            [\n                SetUpInstruction.from_object(instruction)\n                for instruction in d[ManifestFormattedDictKeys.SET_UP]\n            ],\n            [HttpScene.from_dict(scene) for scene in d[ManifestFormattedDictKeys.SCENES]],\n            {\n                case_id: Case.from_id_and_dict(case_id, case_dict)\n                for case_id, case_dict in d[ManifestFormattedDictKeys.CASES].items()\n            },\n            d[ManifestFormattedDictKeys.MANIFEST_ORIGIN],\n        )\n</code></pre>"},{"location":"api/#scenery.manifest.ManifestDictKeys","title":"<code>ManifestDictKeys</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Keys allowed for Manifest.from_dict (and .from_yaml)</p> Source code in <code>scenery/manifest.py</code> <pre><code>class ManifestDictKeys(enum.Enum):\n    \"\"\"Keys allowed for Manifest.from_dict (and .from_yaml)\"\"\"\n\n    SET_UP_TEST_DATA = \"set_up_test_data\"\n    SET_UP = \"set_up\"\n    CASES = \"cases\"\n    SCENES = \"scenes\"\n    MANIFEST_ORIGIN = \"manifest_origin\"\n\n    CASE = \"case\"\n    SCENE = \"scene\"\n</code></pre>"},{"location":"api/#scenery.manifest.ManifestFormattedDictKeys","title":"<code>ManifestFormattedDictKeys</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Used in formated dict, they are exactly contained when passed in Manifest.from_formatted_dict</p> Source code in <code>scenery/manifest.py</code> <pre><code>class ManifestFormattedDictKeys(enum.Enum):\n    \"\"\"Used in formated dict, they are exactly contained when passed in Manifest.from_formatted_dict\"\"\"\n\n    SET_UP_TEST_DATA = \"set_up_test_data\"\n    SET_UP = \"set_up\"\n    CASES = \"cases\"\n    SCENES = \"scenes\"\n    MANIFEST_ORIGIN = \"manifest_origin\"\n</code></pre>"},{"location":"api/#scenery.manifest.ManifestYAMLKeys","title":"<code>ManifestYAMLKeys</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Keys allowed for Manifest.from_yaml compared to Manifest.from_dict</p> Source code in <code>scenery/manifest.py</code> <pre><code>class ManifestYAMLKeys(enum.Enum):\n    \"\"\"Keys allowed for Manifest.from_yaml compared to Manifest.from_dict\"\"\"\n\n    SET_UP_TEST_DATA = \"set_up_test_data\"\n    SET_UP = \"set_up\"\n    CASES = \"cases\"\n    SCENES = \"scenes\"\n    MANIFEST_ORIGIN = \"manifest_origin\"\n\n    CASE = \"case\"\n    SCENE = \"scene\"\n\n    VARIABLES = \"variables\"\n</code></pre>"},{"location":"api/#scenery.manifest.SetUpInstruction","title":"<code>SetUpInstruction</code>  <code>dataclass</code>","text":"<p>Store the command and potential arguments for setUpTestData and setUp</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass SetUpInstruction:\n    \"\"\"Store the command and potential arguments for setUpTestData and setUp\"\"\"\n\n    command: str\n    args: dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_object(cls, x: str | dict) -&gt; \"SetUpInstruction\":\n        match x:\n            case str(s):\n                cmd_name, args = s, {}\n            case dict(d) if len(d) == 1:\n                cmd_name, args = SingleKeyDict(d).as_tuple()\n            case dict(d):\n                raise ValueError(\n                    f\"`SetUpInstruction` cannot be instantiated from dictionnary of length {len(x)}\\n{x}\"\n                )\n            case _:\n                raise TypeError(f\"`SetUpInstruction` cannot be instantiated from {type(x)}\")\n\n        # return cls(SetUpCommand(cmd_name), args)\n        return cls(cmd_name, args)\n</code></pre>"},{"location":"api/#scenery.manifest.SingleKeyDict","title":"<code>SingleKeyDict</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[SingleKeyDictKey, SingleKeyDictKeyValue]</code></p> <p>A dataclass representing a dictionary with a single key-value pair.</p> <p>This class is useful for having a quick as_tuple representation of a dict {key:value} returned as (key, value).</p> <p>Attributes:</p> Name Type Description <code>_dict</code> <code>Dict[SingleKeyDictKey, SingleKeyDictKeyValue]</code> <p>The underlying dictionary.</p> <code>key</code> <code>SingleKeyDictKey</code> <p>The single key in the dictionary.</p> <code>value</code> <code>SingleKeyDictKeyValue</code> <p>The value associated with the single key.</p> <p>Methods:</p> Name Description <code>validate</code> <p>Ensures the dictionary has exactly one key-value pair.</p> <code>as_tuple</code> <p>Returns the key-value pair as a tuple.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary does not contain exactly one key-value pair.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass SingleKeyDict(typing.Generic[SingleKeyDictKey, SingleKeyDictKeyValue]):\n    \"\"\"\n    A dataclass representing a dictionary with a single key-value pair.\n\n    This class is useful for having a quick as_tuple representation of a dict {key:value}\n    returned as (key, value).\n\n    Attributes:\n        _dict (Dict[SingleKeyDictKey, SingleKeyDictKeyValue]): The underlying dictionary.\n        key (SingleKeyDictKey): The single key in the dictionary.\n        value (SingleKeyDictKeyValue): The value associated with the single key.\n\n    Methods:\n        validate(): Ensures the dictionary has exactly one key-value pair.\n        as_tuple(): Returns the key-value pair as a tuple.\n\n    Raises:\n        ValueError: If the dictionary does not contain exactly one key-value pair.\n    \"\"\"\n\n    _dict: typing.Dict[SingleKeyDictKey, SingleKeyDictKeyValue] = field()\n    key: SingleKeyDictKey = field(init=False)\n    value: SingleKeyDictKeyValue = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        self.validate()\n        self.key, self.value = next(iter(self._dict.items()))\n\n    def validate(self) -&gt; None:\n        if len(self._dict) != 1:\n            raise ValueError(\n                f\"SingleKeyDict should have length 1 not '{len(self._dict)}'\\n{self._dict}\"\n            )\n\n    def as_tuple(self) -&gt; tuple:\n        \"\"\"\ud83d\udd34 This should not be confused with built-in method datclasses.astuple\"\"\"\n        return self.key, self.value\n</code></pre>"},{"location":"api/#scenery.manifest.SingleKeyDict.as_tuple","title":"<code>as_tuple()</code>","text":"<p>\ud83d\udd34 This should not be confused with built-in method datclasses.astuple</p> Source code in <code>scenery/manifest.py</code> <pre><code>def as_tuple(self) -&gt; tuple:\n    \"\"\"\ud83d\udd34 This should not be confused with built-in method datclasses.astuple\"\"\"\n    return self.key, self.value\n</code></pre>"},{"location":"api/#metatest","title":"Metatest","text":""},{"location":"api/#scenery.metatest.MetaTest","title":"<code>MetaTest</code>","text":"<p>               Bases: <code>type</code></p> <p>A metaclass for creating test classes dynamically based on a Manifest.</p> <p>This metaclass creates test methods for each combination of case and scene in the manifest, and adds setup methods to the test class.</p> <p>Parameters:</p> Name Type Description Default <code>clsname</code> <code>str</code> <p>The name of the class being created.</p> required <code>bases</code> <code>tuple</code> <p>The base classes of the class being created.</p> required <code>manifest</code> <code>Manifest</code> <p>The manifest containing test cases and scenes.</p> required <code>restrict</code> <code>str</code> <p>A string to restrict which tests are created, in the format \"case_id.scene_pos\".</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>A new test class with dynamically created test methods.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the restrict argument is not in the correct format.</p> Source code in <code>scenery/metatest.py</code> <pre><code>class MetaTest(type):\n    \"\"\"\n    A metaclass for creating test classes dynamically based on a Manifest.\n\n    This metaclass creates test methods for each combination of case and scene in the manifest,\n    and adds setup methods to the test class.\n\n    Args:\n        clsname (str): The name of the class being created.\n        bases (tuple): The base classes of the class being created.\n        manifest (Manifest): The manifest containing test cases and scenes.\n        restrict (str, optional): A string to restrict which tests are created, in the format \"case_id.scene_pos\".\n\n    Returns:\n        type: A new test class with dynamically created test methods.\n\n    Raises:\n        ValueError: If the restrict argument is not in the correct format.\n    \"\"\"\n\n    def __new__(\n        cls,\n        clsname: str,\n        bases: tuple[type],\n        manifest: Manifest,\n        restrict: typing.Optional[str] = None,\n    ) -&gt; \"MetaTest\":\n        if restrict is not None:\n            restrict_args = restrict.split(\".\")\n            if len(restrict_args) == 1:\n                restrict_case_id, restrict_scene_pos = restrict_args[0], None\n            elif len(restrict_args) == 2:\n                restrict_case_id, restrict_scene_pos = restrict_args[0], restrict_args[1]\n            else:\n                raise ValueError(f\"Wrong restrict argmuent {restrict}\")\n\n        # Build setUpTestData and SetUp\n        setUpTestData = MethodBuilder.build_setUpTestData(manifest.set_up_test_data)\n        setUp = MethodBuilder.build_setUp(manifest.set_up)\n\n        # Add SetupData and SetUp as methods of the Test class\n        cls_attrs = {\n            \"setUpTestData\": setUpTestData,\n            \"setUp\": setUp,\n        }\n\n        for (case_id, case), (scene_pos, scene) in itertools.product(\n            manifest.cases.items(), enumerate(manifest.scenes)\n        ):\n            if restrict is not None:\n                if case_id != restrict_case_id:\n                    continue\n                elif restrict_scene_pos is not None and str(scene_pos) != restrict_scene_pos:\n                    continue\n\n            take = scene.shoot(case)\n            test = MethodBuilder.build_test_from_take(take)\n            cls_attrs.update({f\"test_case_{case_id}_scene_{scene_pos}\": test})\n\n        return super().__new__(cls, clsname, bases, cls_attrs)\n</code></pre>"},{"location":"api/#scenery.metatest.MetaTestDiscoverer","title":"<code>MetaTestDiscoverer</code>","text":"<p>A class for discovering and loading test cases from manifest files.</p> <p>This class scans a directory for manifest files, creates test classes from these manifests, and loads the tests into test suites.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger instance for this class.</p> <code>runner</code> <code>DiscoverRunner</code> <p>A Django test runner instance.</p> <code>loader</code> <code>TestLoader</code> <p>A test loader instance from the runner.</p> Source code in <code>scenery/metatest.py</code> <pre><code>class MetaTestDiscoverer:\n    \"\"\"\n    A class for discovering and loading test cases from manifest files.\n\n    This class scans a directory for manifest files, creates test classes from these manifests,\n    and loads the tests into test suites.\n\n    Attributes:\n        logger (Logger): A logger instance for this class.\n        runner (DiscoverRunner): A Django test runner instance.\n        loader (TestLoader): A test loader instance from the runner.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.logger = logging.getLogger(__package__)\n        self.runner = get_runner(settings, test_runner_class=\"django.test.runner.DiscoverRunner\")()\n        self.loader = self.runner.test_loader\n\n    def discover(\n        self, restrict: typing.Optional[str] = None, verbosity: int = 2\n    ) -&gt; list[tuple[str, unittest.TestSuite]]:\n        \"\"\"\n        Discover and load tests from manifest files.\n\n        Args:\n            restrict (str, optional): A string to restrict which manifests and tests are loaded,\n                                      in the format \"manifest.case_id.scene_pos\".\n            verbosity (int, optional): The verbosity level for output. Defaults to 2.\n\n        Returns:\n            list: A list of tuples, each containing a test name and a TestSuite with a single test.\n\n        Raises:\n            ValueError: If the restrict argument is not in the correct format.\n        \"\"\"\n\n        # handle manifest/test restriction\n        if restrict is not None:\n            restrict_args = restrict.split(\".\")\n            if len(restrict_args) == 1:\n                restrict_manifest, restrict_test = (\n                    restrict_args[0],\n                    None,\n                )\n            elif len(restrict_args) == 2:\n                restrict_manifest, restrict_test = (restrict_args[0], restrict_args[1])\n            elif len(restrict_args) == 3:\n                restrict_manifest, restrict_test = (\n                    restrict_args[0],\n                    restrict_args[1] + \".\" + restrict_args[2],\n                )\n        else:\n            restrict_manifest, restrict_test = None, None\n\n        out = []\n\n        suite_cls = self.runner.test_suite\n\n        folder = os.getenv(\"SCENERY_MANIFESTS_FOLDER\")\n\n        if verbosity &gt;= 1:\n            print(\"Manifests discovered:\")\n\n        for filename in os.listdir(folder):\n            manifest_name = filename.replace(\".yml\", \"\")\n\n            if restrict is not None and restrict_manifest != manifest_name:\n                continue\n\n            self.logger.debug(f\"Discovered manifest '{folder}/{filename}'\")\n\n            manifest = ManifestParser.parse_yaml(os.path.join(folder, filename))\n\n            # Create class\n            cls = MetaTest(manifest_name, (django.test.TestCase,), manifest, restrict=restrict_test)\n\n            # Log / verbosity\n            if verbosity &gt;= 2:\n                print(f\"&gt; {cls.__qualname__}\")\n\n            # Load\n            tests = self.loader.loadTestsFromTestCase(cls)\n            for test in tests:\n                test_name = scenery.common.pretty_test_name(test)\n                suite = suite_cls()\n                suite.addTest(test)\n                out.append((test_name, suite))\n\n        msg = f\"Resulting in {len(out)} tests.\"\n        if verbosity &gt;= 1:\n            print(f\"{msg}\\n\")\n        return out\n</code></pre>"},{"location":"api/#scenery.metatest.MetaTestDiscoverer.discover","title":"<code>discover(restrict=None, verbosity=2)</code>","text":"<p>Discover and load tests from manifest files.</p> <p>Parameters:</p> Name Type Description Default <code>restrict</code> <code>str</code> <p>A string to restrict which manifests and tests are loaded,                       in the format \"manifest.case_id.scene_pos\".</p> <code>None</code> <code>verbosity</code> <code>int</code> <p>The verbosity level for output. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[str, TestSuite]]</code> <p>A list of tuples, each containing a test name and a TestSuite with a single test.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the restrict argument is not in the correct format.</p> Source code in <code>scenery/metatest.py</code> <pre><code>def discover(\n    self, restrict: typing.Optional[str] = None, verbosity: int = 2\n) -&gt; list[tuple[str, unittest.TestSuite]]:\n    \"\"\"\n    Discover and load tests from manifest files.\n\n    Args:\n        restrict (str, optional): A string to restrict which manifests and tests are loaded,\n                                  in the format \"manifest.case_id.scene_pos\".\n        verbosity (int, optional): The verbosity level for output. Defaults to 2.\n\n    Returns:\n        list: A list of tuples, each containing a test name and a TestSuite with a single test.\n\n    Raises:\n        ValueError: If the restrict argument is not in the correct format.\n    \"\"\"\n\n    # handle manifest/test restriction\n    if restrict is not None:\n        restrict_args = restrict.split(\".\")\n        if len(restrict_args) == 1:\n            restrict_manifest, restrict_test = (\n                restrict_args[0],\n                None,\n            )\n        elif len(restrict_args) == 2:\n            restrict_manifest, restrict_test = (restrict_args[0], restrict_args[1])\n        elif len(restrict_args) == 3:\n            restrict_manifest, restrict_test = (\n                restrict_args[0],\n                restrict_args[1] + \".\" + restrict_args[2],\n            )\n    else:\n        restrict_manifest, restrict_test = None, None\n\n    out = []\n\n    suite_cls = self.runner.test_suite\n\n    folder = os.getenv(\"SCENERY_MANIFESTS_FOLDER\")\n\n    if verbosity &gt;= 1:\n        print(\"Manifests discovered:\")\n\n    for filename in os.listdir(folder):\n        manifest_name = filename.replace(\".yml\", \"\")\n\n        if restrict is not None and restrict_manifest != manifest_name:\n            continue\n\n        self.logger.debug(f\"Discovered manifest '{folder}/{filename}'\")\n\n        manifest = ManifestParser.parse_yaml(os.path.join(folder, filename))\n\n        # Create class\n        cls = MetaTest(manifest_name, (django.test.TestCase,), manifest, restrict=restrict_test)\n\n        # Log / verbosity\n        if verbosity &gt;= 2:\n            print(f\"&gt; {cls.__qualname__}\")\n\n        # Load\n        tests = self.loader.loadTestsFromTestCase(cls)\n        for test in tests:\n            test_name = scenery.common.pretty_test_name(test)\n            suite = suite_cls()\n            suite.addTest(test)\n            out.append((test_name, suite))\n\n    msg = f\"Resulting in {len(out)} tests.\"\n    if verbosity &gt;= 1:\n        print(f\"{msg}\\n\")\n    return out\n</code></pre>"},{"location":"api/#scenery.metatest.MetaTestRunner","title":"<code>MetaTestRunner</code>","text":"<p>A class for running discovered tests and collecting results.</p> <p>This class takes discovered tests, runs them using a Django test runner, and collects and formats the results.</p> <p>Attributes:</p> Name Type Description <code>runner</code> <code>DiscoverRunner</code> <p>A Django test runner instance.</p> <code>logger</code> <code>Logger</code> <p>A logger instance for this class.</p> <code>discoverer</code> <code>MetaTestDiscoverer</code> <p>An instance of MetaTestDiscoverer for discovering tests.</p> <code>stream</code> <code>StringIO</code> <p>A string buffer for capturing test output.</p> Source code in <code>scenery/metatest.py</code> <pre><code>class MetaTestRunner:\n    \"\"\"\n    A class for running discovered tests and collecting results.\n\n    This class takes discovered tests, runs them using a Django test runner,\n    and collects and formats the results.\n\n    Attributes:\n        runner (DiscoverRunner): A Django test runner instance.\n        logger (Logger): A logger instance for this class.\n        discoverer (MetaTestDiscoverer): An instance of MetaTestDiscoverer for discovering tests.\n        stream (StringIO): A string buffer for capturing test output.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the MetaTestRunner with a runner, logger, discoverer, and output stream.\"\"\"\n\n        self.runner = get_runner(settings, test_runner_class=\"django.test.runner.DiscoverRunner\")()\n        self.logger = logging.getLogger(__package__)\n\n        self.stream = io.StringIO()\n\n        def overwrite(runner):\n            return scenery.common.overwrite_get_runner_kwargs(runner, self.stream)\n\n        self.runner.get_test_runner_kwargs = overwrite.__get__(self.runner)\n        app_logger = logging.getLogger(\"app.close_watch\")\n        app_logger.propagate = False\n\n    def __del__(self) -&gt; None:\n        \"\"\"Clean up resources when the MetaTestRunner is deleted.\"\"\"\n        # TODO: a context manager would be ideal, let's wait v2\n        self.stream.close()\n        app_logger = logging.getLogger(\"app.close_watch\")\n        app_logger.propagate = True\n\n    def run(self, tests_discovered, verbosity) -&gt; dict[str, dict[str, typing.Any]]:\n        \"\"\"\n        Run the discovered tests and collect results.\n\n        Args:\n            tests_discovered (list): A list of tuples, each containing a test name and a TestSuite.\n            verbosity (int): The verbosity level for output.\n\n        Returns:\n            dict: A dictionary mapping test names to their serialized results.\n\n        Note:\n            This method logs test results and prints them to the console based on the verbosity level.\n        \"\"\"\n        if verbosity &gt; 0:\n            print(\"Tests runs:\")\n\n        results = {}\n        for test_name, suite in tests_discovered:\n            result = self.runner.run_suite(suite)\n\n            result_serialized = scenery.common.serialize_unittest_result(result)\n\n            test_name = test_name.replace(\"test_case_\", \"\")\n            test_name = test_name.replace(\"_scene_\", \".\")\n\n            results[test_name] = result_serialized\n\n            if result.errors or result.failures:\n                log_lvl, color = logging.ERROR, \"red\"\n            else:\n                log_lvl, color = logging.INFO, \"green\"\n            self.logger.log(log_lvl, f\"{test_name}\\n{scenery.common.tabulate(result_serialized)}\")\n            if verbosity &gt; 0:\n                print(\n                    f\"&gt;&gt; {scenery.common.colorize(color, test_name)}\\n{scenery.common.tabulate({key: val for key, val in result_serialized.items() if val &gt; 0})}\"\n                )\n\n            # Log / verbosity\n            for head, traceback in result.failures + result.errors:\n                msg = f\"{test_name}\\n{head}\\n{traceback}\"\n                self.logger.error(msg)\n                if verbosity &gt; 0:\n                    print(msg)\n\n        return results\n</code></pre>"},{"location":"api/#scenery.metatest.MetaTestRunner.__del__","title":"<code>__del__()</code>","text":"<p>Clean up resources when the MetaTestRunner is deleted.</p> Source code in <code>scenery/metatest.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Clean up resources when the MetaTestRunner is deleted.\"\"\"\n    # TODO: a context manager would be ideal, let's wait v2\n    self.stream.close()\n    app_logger = logging.getLogger(\"app.close_watch\")\n    app_logger.propagate = True\n</code></pre>"},{"location":"api/#scenery.metatest.MetaTestRunner.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the MetaTestRunner with a runner, logger, discoverer, and output stream.</p> Source code in <code>scenery/metatest.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the MetaTestRunner with a runner, logger, discoverer, and output stream.\"\"\"\n\n    self.runner = get_runner(settings, test_runner_class=\"django.test.runner.DiscoverRunner\")()\n    self.logger = logging.getLogger(__package__)\n\n    self.stream = io.StringIO()\n\n    def overwrite(runner):\n        return scenery.common.overwrite_get_runner_kwargs(runner, self.stream)\n\n    self.runner.get_test_runner_kwargs = overwrite.__get__(self.runner)\n    app_logger = logging.getLogger(\"app.close_watch\")\n    app_logger.propagate = False\n</code></pre>"},{"location":"api/#scenery.metatest.MetaTestRunner.run","title":"<code>run(tests_discovered, verbosity)</code>","text":"<p>Run the discovered tests and collect results.</p> <p>Parameters:</p> Name Type Description Default <code>tests_discovered</code> <code>list</code> <p>A list of tuples, each containing a test name and a TestSuite.</p> required <code>verbosity</code> <code>int</code> <p>The verbosity level for output.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, dict[str, Any]]</code> <p>A dictionary mapping test names to their serialized results.</p> Note <p>This method logs test results and prints them to the console based on the verbosity level.</p> Source code in <code>scenery/metatest.py</code> <pre><code>def run(self, tests_discovered, verbosity) -&gt; dict[str, dict[str, typing.Any]]:\n    \"\"\"\n    Run the discovered tests and collect results.\n\n    Args:\n        tests_discovered (list): A list of tuples, each containing a test name and a TestSuite.\n        verbosity (int): The verbosity level for output.\n\n    Returns:\n        dict: A dictionary mapping test names to their serialized results.\n\n    Note:\n        This method logs test results and prints them to the console based on the verbosity level.\n    \"\"\"\n    if verbosity &gt; 0:\n        print(\"Tests runs:\")\n\n    results = {}\n    for test_name, suite in tests_discovered:\n        result = self.runner.run_suite(suite)\n\n        result_serialized = scenery.common.serialize_unittest_result(result)\n\n        test_name = test_name.replace(\"test_case_\", \"\")\n        test_name = test_name.replace(\"_scene_\", \".\")\n\n        results[test_name] = result_serialized\n\n        if result.errors or result.failures:\n            log_lvl, color = logging.ERROR, \"red\"\n        else:\n            log_lvl, color = logging.INFO, \"green\"\n        self.logger.log(log_lvl, f\"{test_name}\\n{scenery.common.tabulate(result_serialized)}\")\n        if verbosity &gt; 0:\n            print(\n                f\"&gt;&gt; {scenery.common.colorize(color, test_name)}\\n{scenery.common.tabulate({key: val for key, val in result_serialized.items() if val &gt; 0})}\"\n            )\n\n        # Log / verbosity\n        for head, traceback in result.failures + result.errors:\n            msg = f\"{test_name}\\n{head}\\n{traceback}\"\n            self.logger.error(msg)\n            if verbosity &gt; 0:\n                print(msg)\n\n    return results\n</code></pre>"},{"location":"api/#method-builder","title":"Method builder","text":""},{"location":"api/#scenery.method_builder.MethodBuilder","title":"<code>MethodBuilder</code>","text":"<p>A utility class for building test methods dynamically based on manifest data.</p> <p>This class provides static methods to create setup and test methods that can be added to Django test cases.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>class MethodBuilder:\n    \"\"\"\n    A utility class for building test methods dynamically based on manifest data.\n\n    This class provides static methods to create setup and test methods\n    that can be added to Django test cases.\n    \"\"\"\n\n    @staticmethod\n    def build_setUpTestData(instructions: list[scenery.manifest.SetUpInstruction]) -&gt; classmethod:\n        \"\"\"\n        Build a setUpTestData class method for a Django test case.\n\n        This method creates a class method that executes a series of setup\n        instructions before any test methods are run.\n\n        Args:\n            instructions (list[str]): A list of setup instructions to be executed.\n\n        Returns:\n            classmethod: A class method that can be added to a Django test case.\n        \"\"\"\n\n        def setUpTestData(django_testcase: django.test.TestCase) -&gt; None:\n            for instruction in instructions:\n                SetUpHandler.exec_set_up_instruction(django_testcase, instruction)\n\n        return classmethod(setUpTestData)\n\n    @staticmethod\n    def build_setUp(\n        instructions: list[scenery.manifest.SetUpInstruction],\n    ) -&gt; Callable[[django.test.TestCase], None]:\n        \"\"\"\n        Build a setUp instance method for a Django test case.\n\n        This method creates an instance method that executes a series of setup\n        instructions before each test method is run.\n\n        Args:\n            instructions (list[str]): A list of setup instructions to be executed.\n\n        Returns:\n            function: An instance method that can be added to a Django test case.\n        \"\"\"\n\n        def setUp(django_testcase: django.test.TestCase) -&gt; None:\n            for instruction in instructions:\n                SetUpHandler.exec_set_up_instruction(django_testcase, instruction)\n\n        return setUp\n\n    @staticmethod\n    def build_test_from_take(take: scenery.manifest.HttpTake) -&gt; Callable:\n        \"\"\"\n        Build a test method from an HttpTake object.\n\n        This method creates a test function that sends an HTTP request\n        based on the take's specifications and executes a series of checks\n        on the response.\n\n        Args:\n            take (scenery.manifest.HttpTake): An HttpTake object specifying\n                the request to be made and the checks to be performed.\n\n        Returns:\n            function: A test method that can be added to a Django test case.\n        \"\"\"\n\n        def test(django_testcase: django.test.TestCase) -&gt; None:\n            response = HttpChecker.get_http_client_response(django_testcase.client, take)\n            for i, check in enumerate(take.checks):\n                with django_testcase.subTest(i=i):\n                    HttpChecker.exec_check(django_testcase, response, check)\n\n        return test\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_setUp","title":"<code>build_setUp(instructions)</code>  <code>staticmethod</code>","text":"<p>Build a setUp instance method for a Django test case.</p> <p>This method creates an instance method that executes a series of setup instructions before each test method is run.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[str]</code> <p>A list of setup instructions to be executed.</p> required <p>Returns:</p> Name Type Description <code>function</code> <code>Callable[[TestCase], None]</code> <p>An instance method that can be added to a Django test case.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_setUp(\n    instructions: list[scenery.manifest.SetUpInstruction],\n) -&gt; Callable[[django.test.TestCase], None]:\n    \"\"\"\n    Build a setUp instance method for a Django test case.\n\n    This method creates an instance method that executes a series of setup\n    instructions before each test method is run.\n\n    Args:\n        instructions (list[str]): A list of setup instructions to be executed.\n\n    Returns:\n        function: An instance method that can be added to a Django test case.\n    \"\"\"\n\n    def setUp(django_testcase: django.test.TestCase) -&gt; None:\n        for instruction in instructions:\n            SetUpHandler.exec_set_up_instruction(django_testcase, instruction)\n\n    return setUp\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_setUpTestData","title":"<code>build_setUpTestData(instructions)</code>  <code>staticmethod</code>","text":"<p>Build a setUpTestData class method for a Django test case.</p> <p>This method creates a class method that executes a series of setup instructions before any test methods are run.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[str]</code> <p>A list of setup instructions to be executed.</p> required <p>Returns:</p> Name Type Description <code>classmethod</code> <code>classmethod</code> <p>A class method that can be added to a Django test case.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_setUpTestData(instructions: list[scenery.manifest.SetUpInstruction]) -&gt; classmethod:\n    \"\"\"\n    Build a setUpTestData class method for a Django test case.\n\n    This method creates a class method that executes a series of setup\n    instructions before any test methods are run.\n\n    Args:\n        instructions (list[str]): A list of setup instructions to be executed.\n\n    Returns:\n        classmethod: A class method that can be added to a Django test case.\n    \"\"\"\n\n    def setUpTestData(django_testcase: django.test.TestCase) -&gt; None:\n        for instruction in instructions:\n            SetUpHandler.exec_set_up_instruction(django_testcase, instruction)\n\n    return classmethod(setUpTestData)\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_test_from_take","title":"<code>build_test_from_take(take)</code>  <code>staticmethod</code>","text":"<p>Build a test method from an HttpTake object.</p> <p>This method creates a test function that sends an HTTP request based on the take's specifications and executes a series of checks on the response.</p> <p>Parameters:</p> Name Type Description Default <code>take</code> <code>HttpTake</code> <p>An HttpTake object specifying the request to be made and the checks to be performed.</p> required <p>Returns:</p> Name Type Description <code>function</code> <code>Callable</code> <p>A test method that can be added to a Django test case.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_test_from_take(take: scenery.manifest.HttpTake) -&gt; Callable:\n    \"\"\"\n    Build a test method from an HttpTake object.\n\n    This method creates a test function that sends an HTTP request\n    based on the take's specifications and executes a series of checks\n    on the response.\n\n    Args:\n        take (scenery.manifest.HttpTake): An HttpTake object specifying\n            the request to be made and the checks to be performed.\n\n    Returns:\n        function: A test method that can be added to a Django test case.\n    \"\"\"\n\n    def test(django_testcase: django.test.TestCase) -&gt; None:\n        response = HttpChecker.get_http_client_response(django_testcase.client, take)\n        for i, check in enumerate(take.checks):\n            with django_testcase.subTest(i=i):\n                HttpChecker.exec_check(django_testcase, response, check)\n\n    return test\n</code></pre>"},{"location":"api/#method-builder_1","title":"Method builder","text":""},{"location":"api/#scenery.set_up_handler.SetUpHandler","title":"<code>SetUpHandler</code>","text":"<p>Responsible for executing instructions used in <code>TestCase.setUp</code> and <code>TestCase.setUpTestData</code> provided in the manifest.</p> <p>This class dynamically imports and executes setup instructions specified in the test manifest. It is typically used by the MethodBuilder to construct setup methods for test cases.</p> <p>Attributes:</p> Name Type Description <code>module</code> <p>The imported module containing setup instruction implementations.</p> <code>logger</code> <p>A logger instance for debug output.</p> Source code in <code>scenery/set_up_handler.py</code> <pre><code>class SetUpHandler:\n    \"\"\"\n    Responsible for executing instructions used in `TestCase.setUp` and `TestCase.setUpTestData`\n    provided in the manifest.\n\n    This class dynamically imports and executes setup instructions specified in the test manifest.\n    It is typically used by the MethodBuilder to construct setup methods for test cases.\n\n    Attributes:\n        module: The imported module containing setup instruction implementations.\n        logger: A logger instance for debug output.\n    \"\"\"\n\n    module = importlib.import_module(\n        os.getenv(\"SCENERY_SET_UP_INSTRUCTIONS\"),\n    )\n\n    @staticmethod\n    def exec_set_up_instruction(\n        django_testcase: django.test.TestCase,\n        instruction: scenery.manifest.SetUpInstruction,\n    ):\n        \"\"\"\n        Execute the method corresponding to the SetUpInstruction.\n\n        This method dynamically retrieves and executes the setup function specified\n        by the SetUpInstruction. It logs the execution for debugging purposes.\n\n        Args:\n            django_testcase (django.test.TestCase): The Django test case instance.\n            instruction (scenery.manifest.SetUpInstruction): The setup instruction to execute.\n\n        Raises:\n            AttributeError: If the specified setup function is not found in the imported module.\n        \"\"\"\n\n        func = getattr(SetUpHandler.module, instruction.command)\n        func(django_testcase, **instruction.args)\n\n        logger = logging.getLogger(__package__)\n        logger.debug(f\"Applied {instruction}\")\n</code></pre>"},{"location":"api/#scenery.set_up_handler.SetUpHandler.exec_set_up_instruction","title":"<code>exec_set_up_instruction(django_testcase, instruction)</code>  <code>staticmethod</code>","text":"<p>Execute the method corresponding to the SetUpInstruction.</p> <p>This method dynamically retrieves and executes the setup function specified by the SetUpInstruction. It logs the execution for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>django_testcase</code> <code>TestCase</code> <p>The Django test case instance.</p> required <code>instruction</code> <code>SetUpInstruction</code> <p>The setup instruction to execute.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the specified setup function is not found in the imported module.</p> Source code in <code>scenery/set_up_handler.py</code> <pre><code>@staticmethod\ndef exec_set_up_instruction(\n    django_testcase: django.test.TestCase,\n    instruction: scenery.manifest.SetUpInstruction,\n):\n    \"\"\"\n    Execute the method corresponding to the SetUpInstruction.\n\n    This method dynamically retrieves and executes the setup function specified\n    by the SetUpInstruction. It logs the execution for debugging purposes.\n\n    Args:\n        django_testcase (django.test.TestCase): The Django test case instance.\n        instruction (scenery.manifest.SetUpInstruction): The setup instruction to execute.\n\n    Raises:\n        AttributeError: If the specified setup function is not found in the imported module.\n    \"\"\"\n\n    func = getattr(SetUpHandler.module, instruction.command)\n    func(django_testcase, **instruction.args)\n\n    logger = logging.getLogger(__package__)\n    logger.debug(f\"Applied {instruction}\")\n</code></pre>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#rehearsal","title":"Rehearsal","text":"<p>Testing the scenery package itself. </p>"},{"location":"glossary/#scene","title":"Scene","text":"<p>A scene describes an event from the app perspective. It additionally describe the expected behavior of the app regarding this event by what we call a directive.</p> <p>A scene can rely on a substituable field, i.e. a field for which the value is placeholder that will be replaced by different potential values coming from what we call cases. This allows to check that the app behaves in a similar way with different values for this field. Such field can be used in the scene description or in a directive.</p>"},{"location":"glossary/#case","title":"Case","text":"<p>A case contains information that can be used to fill the substituable fields of a scene. A case has an id and a list of items. All cases applied to a given scene need to have a list of similar items. </p>"},{"location":"glossary/#take","title":"Take","text":"<p>A take is a scene in which all substituable fields have been replaced based on a particular case. We say that the take is the result of shooting the scene with a given case.</p> <p>Once shot, a directive is designated as a check.</p>"},{"location":"glossary/#manifest","title":"Manifest","text":"<p>A manifest contains all required information to build and run tests based on some scene(s) and case(s).</p>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install pca-scenery\n</code></pre>"},{"location":"manifest_specification/","title":"Manifest specification","text":"<p>See Glossary for definitions.</p>"},{"location":"manifest_specification/#basic-syntax","title":"Basic syntax","text":""},{"location":"manifest_specification/#scenes","title":"Scene(s)","text":"<p>Required.</p> <p><pre><code>scene:\n  method: ...\n  url: ...\n  data: ...\n  directives:\n  - status_code: ...\n  - redirect_url: ...\n</code></pre> or </p> <pre><code>scenes:\n- method: ...\n  url: ...\n  data: ...\n  directives:\n  - status_code: ...\n  - redirect_url: ...\n  ...\n</code></pre> <p>An HTTP scene is defined by: - a method (<code>GET</code>, <code>POST</code>, ...) - an url - some data (optional) - some url parameters (optional) - some query parameters (optional)</p> <p>An HTTP directive may be related to: - the response status code - the redirect url - some DOM element of the returned html - the state of the database (e.g. counting the instances of a model)</p> <p>See ?? for more details</p>"},{"location":"manifest_specification/#cases","title":"Case(s)","text":"<p>Optional. <pre><code>case:\n  item_1:\n    foo: ...\n  item_2:\n    bar: ...\n</code></pre> or <pre><code>cases:\n  CASE_A:\n    item_1:\n        foo: ...\n    item_2:\n      bar: ...\n  CASE_B:\n    item_1:\n        foo: ...\n    item_2:\n      bar: ...\n</code></pre></p>"},{"location":"manifest_specification/#set-up","title":"Set up","text":"<p>Two optional keys: - <code>set_up_test_data</code> - <code>set_up</code></p> <p>They contain lists of instructions executed the tests contained in the manifest.  Some instructions require keyword arguments that need to be passed as a dictionary. </p> <p>Instructions in <code>set_up_test_data</code> are executed be once before for all tests. <code>setup</code> instructions are executed before each test contained in the manifest. This is the exact same syntax and commands as for <code>set_up_test_data</code>.</p> <pre><code>set_up_test_data:\n  - reset_db\n  - create_testuser:\n      first_name : Jane\n      last_name : Doe\n      ...\n</code></pre> <p>The functions name and args should correspond to what is defined in the module attached to <code>SCENERY_SET_UP_INSTRUCTIONS</code> in <code>scenery_settings.py</code></p>"},{"location":"manifest_specification/#substituable-fields","title":"Substituable fields","text":"<p>To indicate that a field is substituable, use the <code>!case</code> tag with one of the following syntax:</p> <ol> <li>Whole item</li> </ol> <pre><code>case:\n  item: ...\nscene:\n  - ...\n    data:\n      item: !case \"item\"\n</code></pre> <ol> <li>Single field</li> </ol> <pre><code>case:\n  item:\n    foo: ...\n    bar: ...\nscene:\n  - ...\n    data:\n      item_foo: !case \"item:foo\"\n</code></pre>"},{"location":"manifest_specification/#common-items","title":"Common items","text":"<p>Common items allow you to use one single YAML file to store some data that you can refer to in your manifest. This helps you keeping the code base more readable. For instance, it can help store the information of your test user. HERE</p> <p>The path to the <code>.yml</code> file is defined under <code>SCENERY_COMMON_ITEMS</code> in <code>scenery_settings.py</code></p> <pre><code>ITEM_ID1:\n  foo: 0\nITEM_ID2:\n  bar: \"a\" \n</code></pre> <p>In the manifest, two possible syntax can be used with the <code>!common-item</code> tag</p> <ol> <li> <p>access directly the item <pre><code>set_up_test_data:\n    - reset_db\n    - create_testuser: !common-item TESTUSER\n</code></pre></p> </li> <li> <p>access the item and add/overwrite a given (key, value) pair of the item <pre><code>set_up_test_data:\n  - reset_db\n  - create_testuser: !common-item \n    ID: TESTUSER # this is the ID as it appears in the common items YAML file\n    foo: 42 # overwrites the foo attribute\n</code></pre></p> </li> </ol>"},{"location":"manifest_specification/#yaml-aliases","title":"YAML aliases","text":"<p>[!danger] Aliases do not work as expected, especially when interacting with <code>!case</code> and <code>!common-items</code> tages, so don't use them. It's because YAML aliases are resolved before tags which are not \"transported\" in the alias.</p>"},{"location":"manifest_specification/#last-thoughts","title":"Last thoughts","text":"<p>The manifest specification provide different ways to avoid the repetition of information. As a consequence, there is not a unique manifest resulting in a given set of tests. Below are still some guidelines to choose how to write a manifest:</p> <ul> <li>Scene vs. Case: <ul> <li>Information describing the state/behavior of the app should be hard-coded in the scene. </li> <li>Information coming from the user's input should coded as a substituable field using <code>!case</code>.</li> <li>Information about content from the database may be coded as one or the other. Readability and maintainability should be your priority, then conciseness.</li> </ul> </li> </ul>"},{"location":"settings/","title":"Settings","text":"<p>Settings are stored in a specific module, by default at the root of the directory you are calling <code>scenery</code> from in a file called <code>scenery_settings.py</code>.</p> <p>If you prefer to use another naming convention or locate the file somewhere else, simply use the <code>--scenery_settings</code> option from the CLI.</p> <pre><code>python -m scenery --scenery_settings=path/to/scenery_settings.py --django_settings=your.dango.settings\n ```\n\n The file should look like this:\n\n```python\n# scenery_settings.py\nSCENERY_MANIFESTS_FOLDER = \"path/to/your/manifests\"\nSCENERY_COMMON_ITEMS = \"path/to/shared/data.yml\"\nSCENERY_SET_UP_INSTRUCTIONS = \"path/to/your/set_up_tear_down_functions\"\nSCENERY_TESTED_APP_NAME = \"your_app_name\"\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#test-manifests","title":"Test Manifests","text":"<p>With <code>scenery</code>, integration tests are configured using YAML, a human-readable data serialization language, making maintenance easy for developers. A given YAML file is called a manifest.</p> <p>In a manifest, a test is described by a scene which defines the request to a given URL and the checks (called directives) that should be applied to the HTTP response.</p>"},{"location":"usage/#example-1-simple-get-request","title":"Example 1: Simple GET request","text":"<pre><code>scene:\n  method: GET\n  url: \"index\"\n  directives:\n    - status_code: 200\n</code></pre> <p>This test sends a GET request to the '/index' URL and checks if the returned status code is 200.</p>"},{"location":"usage/#example-2-post-request-with-data","title":"Example 2: POST request with data","text":"<pre><code>cases:\n  CASE_A:\n    item_1:\n        foo: 0\n  CASE_B:\n    item_1:\n        foo: 1\n\nscene:\n  method: POST\n  url: \"item\"\n  data:\n    item_id: !case item_1:foo\n  directives:\n    - status_code: 200\n</code></pre> <p>This test sends a POST request to the '/item' URL with <code>{item_id: 0}</code> and <code>{item_id: 1}</code> as data and checks if the returned status code is 200.</p>"},{"location":"usage/#advanced-features","title":"Advanced Features","text":"<p>The full syntax of <code>scenery</code> allows you to:</p> <ul> <li>Test a given scene with different data sets</li> <li>Shared data for use across multiple tests</li> <li>Have full control over set-up </li> <li>Use variables and templating in your YAML files</li> </ul> <p>See the full manifest specification for more details.</p>"},{"location":"usage/#settings","title":"Settings","text":"<p><code>scenery</code> relies on 4 environment variables, which can be easily provided by a <code>scenery_settings.py</code> file at the root of your project (or any location you prefer).</p> <p>You also need to provide the Django settings you want to use. Here's an example <code>scenery_settings.py</code>:</p> <pre><code># scenery_settings.py\nSCENERY_MANIFESTS_FOLDER = \"path/to/your/manifests\"\nSCENERY_COMMON_ITEMS = \"path/to/shared/data.yml\"\nSCENERY_SET_UP_INSTRUCTIONS = \"path/to/your/set_up_tear_down_functions\"\nSCENERY_TESTED_APP_NAME = \"your_app_name\"\n</code></pre>"},{"location":"usage/#running-tests","title":"Running Tests","text":"<p>To run your tests, use the following command:</p> <pre><code>python -m scenery --django_settings=your_project.settings.test\n</code></pre> <p>You can also add additional command-line arguments to filter tests, set verbosity, etc. Run <code>python -m scenery --help</code> for more information.</p>"},{"location":"examples/basic/","title":"Basic example","text":""}]}